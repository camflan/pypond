<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pypond package &mdash; pypond 0.5.0 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.6/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/esnet/esnet.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="pypond 0.5.0 documentation" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          <!-- LOGO:  _static/ -->
          pypond</a>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Section <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="time.html">Notes on time handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="columns.html">Data columns: field_spec and field_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="sanitize.html">Fill and other sanitizing methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="release.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests.html">Running the tests</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            <li class="divider-vertical"></li>
            
                <li><a href="genindex.html">Index</a></li>
                <li><a href="https://www.es.net">ESnet</a></li>
            
            <li><a href="https://github.com/esnet/pypond"><img src="_static/esnet/icon-github.png" height="20" width="20"></a></li>
            
            
            
          </ul>
          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">pypond package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pypond.bases">pypond.bases module</a></li>
<li><a class="reference internal" href="#module-pypond.collection">pypond.collection module</a></li>
<li><a class="reference internal" href="#module-pypond.event">pypond.event module</a></li>
<li><a class="reference internal" href="#module-pypond.exceptions">pypond.exceptions module</a></li>
<li><a class="reference internal" href="#module-pypond.functions">pypond.functions module</a></li>
<li><a class="reference internal" href="#module-pypond.index">pypond.index module</a></li>
<li><a class="reference internal" href="#module-pypond.indexed_event">pypond.indexed_event module</a></li>
<li><a class="reference internal" href="#module-pypond.pipeline">pypond.pipeline module</a></li>
<li><a class="reference internal" href="#module-pypond.range">pypond.range module</a></li>
<li><a class="reference internal" href="#module-pypond.series">pypond.series module</a></li>
<li><a class="reference internal" href="#module-pypond.timerange_event">pypond.timerange_event module</a></li>
<li><a class="reference internal" href="#module-pypond.util">pypond.util module</a></li>
<li><a class="reference internal" href="#module-pypond">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9">
      
  <div class="section" id="pypond-package">
<h1>pypond package<a class="headerlink" href="#pypond-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pypond.io.html">pypond.io package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pypond.io.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.io.html#module-pypond.io.input">pypond.io.input module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.io.html#module-pypond.io.output">pypond.io.output module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.io.html#module-pypond.io">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pypond.processor.html">pypond.processor package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.aggregator">pypond.processor.aggregator module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.align">pypond.processor.align module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.base">pypond.processor.base module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.collapser">pypond.processor.collapser module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.converter">pypond.processor.converter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.filler">pypond.processor.filler module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.filter">pypond.processor.filter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.mapper">pypond.processor.mapper module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.offset">pypond.processor.offset module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.rate">pypond.processor.rate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.selector">pypond.processor.selector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor.taker">pypond.processor.taker module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypond.processor.html#module-pypond.processor">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pypond.bases">
<span id="pypond-bases-module"></span><h2>pypond.bases module<a class="headerlink" href="#module-pypond.bases" title="Permalink to this headline">¶</a></h2>
<p>Common base classes and mixins.</p>
<dl class="class">
<dt id="pypond.bases.Observable">
<em class="property">class </em><code class="descclassname">pypond.bases.</code><code class="descname">Observable</code><a class="headerlink" href="#pypond.bases.Observable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.bases.PypondBase" title="pypond.bases.PypondBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.bases.PypondBase</span></code></a></p>
<p>Base class for objects in the processing chain which
need other object to listen to them. It provides a basic
interface to define the relationships and to emit events
to the interested observers.</p>
<dl class="method">
<dt id="pypond.bases.Observable.add_observer">
<code class="descname">add_observer</code><span class="sig-paren">(</span><em>observer</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.bases.Observable.add_observer" title="Permalink to this definition">¶</a></dt>
<dd><p>add an observer if it does not already exist.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.bases.Observable.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.bases.Observable.emit" title="Permalink to this definition">¶</a></dt>
<dd><p>add event to observers.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.bases.Observable.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.bases.Observable.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>flush observers.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.bases.Observable.has_observers">
<code class="descname">has_observers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.bases.Observable.has_observers" title="Permalink to this definition">¶</a></dt>
<dd><p>does the object have observers?</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypond.bases.PypondBase">
<em class="property">class </em><code class="descclassname">pypond.bases.</code><code class="descname">PypondBase</code><a class="headerlink" href="#pypond.bases.PypondBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Universal base class. Used to provide common functionality (logging, etc)
to all the other classes.</p>
</dd></dl>

<dl class="function">
<dt id="pypond.bases.setup_log">
<code class="descclassname">pypond.bases.</code><code class="descname">setup_log</code><span class="sig-paren">(</span><em>log_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.bases.setup_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Usage:
_log(&#8216;main.start&#8217;, &#8216;happy simple log event&#8217;)
_log(&#8216;launch&#8217;, &#8216;more={0}, complex={1} log=event&#8217;.format(100, 200))</p>
</dd></dl>

</div>
<div class="section" id="module-pypond.collection">
<span id="pypond-collection-module"></span><h2>pypond.collection module<a class="headerlink" href="#module-pypond.collection" title="Permalink to this headline">¶</a></h2>
<p>Implementation of Pond Collection class.</p>
<dl class="class">
<dt id="pypond.collection.Collection">
<em class="property">class </em><code class="descclassname">pypond.collection.</code><code class="descname">Collection</code><span class="sig-paren">(</span><em>instance_or_list=None</em>, <em>copy_events=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pypond.io.html#pypond.io.input.Bounded" title="pypond.io.input.Bounded"><code class="xref py py-class docutils literal"><span class="pre">pypond.io.input.Bounded</span></code></a></p>
<p>A collection is a list of Events. You can construct one out of either
another collection, or a list of Events. You can addEvent() to a collection
and a new collection will be returned.</p>
<p>Basic operations on the list of events are also possible. You
can iterate over the collection with a for..of loop, get the size()
of the collection and access a specific element with at().</p>
<p>Initialize from copy, lists, etc.</p>
<p>instance_or_list arg can be:</p>
<ul class="simple">
<li>a Collection object (copy ctor)</li>
<li>a python list</li>
<li>a pyrsistent.pvector</li>
</ul>
<p>The list and pvector will contain Events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>instance_or_list</strong> (<em>list, Collection, pyrsistent.pvector</em>) &#8211; A collection object to copy or a list of Event objects</li>
<li><strong>copy_events</strong> (<em>bool, optional</em>) &#8211; Copy event list when using copy constructor, otherwise the
new object has an emtpy event list.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.collection.Collection.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>call to_string()</p>
<p>to_string() is already being tested so skip coverage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String representation of the object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.add_event">
<code class="descname">add_event</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.add_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an event to the payload and return a new Collection object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>event</strong> (<a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event"><em>Event</em></a>) &#8211; Event object to add to collection.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New collection with the event added to it.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.aggregate">
<code class="descname">aggregate</code><span class="sig-paren">(</span><em>func</em>, <em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregates the events down using a user defined function to
do the reduction. Only a single column can be aggregated on
so this takes a field_path, NOT a field_spec.</p>
<p>This is essentially a wrapper around map/reduce, constraining
it to a single column and returning the value, not the dict
from map().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> (<em>function</em>) &#8211; Function to pass to map reduce to aggregate.</li>
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns the aggregated value, so it depends on what kind
of data are being handled/aggregation being done.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">various</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.at">
<code class="descname">at</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an item in the collection by its index position.</p>
<p>Creates a new object via copy ctor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pos</strong> (<em>int</em>) &#8211; Index of the event to be retrieved.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A new Event object of the event at index pos</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">CollectionException</span></code> &#8211; Raised if there is an index error.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.at_first">
<code class="descname">at_first</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.at_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the first item in this collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An event instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.at_key">
<code class="descname">at_key</code><span class="sig-paren">(</span><em>searchkey</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.at_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of events in the Collection which have
the exact key (time, timerange or index) as the key specified
by &#8216;at&#8217;. Note that this is an O(n) search for the time specified,
since collections are an unordered bag of events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>datetime, str, TimeRange</em>) &#8211; The key of the event</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">List of all events at that key.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.at_last">
<code class="descname">at_last</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.at_last" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last event item in this collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An event instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.at_time">
<code class="descname">at_time</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.at_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an item by time. Primarily a utility method that sits in
front of bisect() and fetches using at().</p>
<p>If you have events at 12:00 and 12:02 and you make the query
at 12:01, the one at 12:00 will be returned. Otherwise it will
return the exact match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> (<em>datetime.datetime</em>) &#8211; Datetime object &gt;= to the event to be returned. Must
be an aware UTC datetime object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns a new Event instance via at()</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.avg">
<code class="descname">avg</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Get avg</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Average value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.bisect">
<code class="descname">bisect</code><span class="sig-paren">(</span><em>dtime</em>, <em>b=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the index that is just less than the time t supplied.
In other words every event at the returned index or less
has a time before the supplied t, and every sample after the
index has a time later than the supplied t.</p>
<p>Optionally supply a begin index to start searching from.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>dtime - python datetime object to bisect collection with</dt>
<dd><p class="first last">will be made into an aware datetime in UTC.</p>
</dd>
</dl>
</li>
<li><p class="first">b - position to start</p>
</li>
</ul>
</div></blockquote>
<p>Returns index that is the greatest but still below t - see docstring
for at_time()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; Datetime object &gt;= to the event to be returned. Must
be an aware UTC datetime object.</li>
<li><strong>b</strong> (<em>int, optional</em>) &#8211; Array index to start searching from</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The index of the searched-for event</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">CollectionException</span></code> &#8211; Raised if given a naive or non-UTC dtime</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.clean">
<code class="descname">clean</code><span class="sig-paren">(</span><em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Collection by testing the fieldSpec
values for being valid (not NaN, null or undefined).
The resulting Collection will be clean for that fieldSpec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New collection containing only &#8220;clean&#8221; events.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.collapse">
<code class="descname">collapse</code><span class="sig-paren">(</span><em>field_spec_list</em>, <em>name</em>, <em>reducer</em>, <em>append=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a fieldSpecList (list of column names) and collapses
them to a new column which is the reduction of the matched columns
in the fieldSpecList.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec_list</strong> (<em>list</em>) &#8211; List of columns to collapse. If you need to retrieve deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].</li>
<li><strong>name</strong> (<em>str</em>) &#8211; Name of new column containing collapsed data.</li>
<li><strong>reducer</strong> (<em>function</em>) &#8211; Function to pass to reducer.</li>
<li><strong>append</strong> (<em>bool, optional</em>) &#8211; Append collapsed column to existing data or make new events with
only that column.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New collection containing the collapsed data.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.count">
<code class="descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get count - calls size()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Num events in the collection.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.dedup">
<code class="descname">dedup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.dedup" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove duplicates from the Collection. If duplicates
exist in the collection with the same key but with different
values, the later event values will be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new collection w/out duplicates.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.collection.Collection.equal">
<em class="property">static </em><code class="descname">equal</code><span class="sig-paren">(</span><em>coll1</em>, <em>coll2</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Test to see if instances are the <em>same instance</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coll1</strong> (<a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection"><em>Collection</em></a>) &#8211; A collection.</li>
<li><strong>coll2</strong> (<a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection"><em>Collection</em></a>) &#8211; Another collection.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if same instance.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.event_list">
<code class="descname">event_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.event_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the raw Immutable event list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Raw immutable event list.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyrsistent.pvector</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.event_list_as_list">
<code class="descname">event_list_as_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.event_list_as_list" title="Permalink to this definition">¶</a></dt>
<dd><p>return a python list of the event list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Thawed version of internal immutable data structure.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.event_list_as_map">
<code class="descname">event_list_as_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.event_list_as_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the events in the collection as a dict of lists where
the key is the timestamp, index or timerange and the value
is an array of events with that key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Description</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">TYPE</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.events">
<code class="descname">events</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.events" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator to allow for..of loops over series.events()</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">series</span><span class="o">.</span><span class="n">events</span><span class="p">():</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An iterator to loop over the events.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iterator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the collection&#8217;s event list with the supplied function.
The function will be passed each of the Event objects and return
a boolean value. If True, then it will be included in the filter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;some_value&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Would produce a new collection where &#8216;some_value&#8217; is only
even numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>func</strong> (<em>function</em>) &#8211; Function to filter with.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New collection containing filtered events.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.first">
<code class="descname">first</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Get first value in the collection for the fspec</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec</strong> (<em>str, list, tuple, None</em>) &#8211; Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.  If None, all columns
will be operated on.</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Type varies depending on underlying data</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">depends on data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.is_chronological">
<code class="descname">is_chronological</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.is_chronological" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the events in this collection are in chronological
order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if events are in chronologcal order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.last">
<code class="descname">last</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Get last value in the collection for the fspec</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec</strong> (<em>str, list, tuple, None</em>) &#8211; Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.  If None, all columns
will be operated on.</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Type varies depending on underlying data</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">depends on data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map function. Apply function to the collection events
and return a new Collection from the resulting events. Function
must creat a new Event* instance.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">in_only</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="c1"># make new events wtin only data value &quot;in&quot;.</span>
    <span class="k">return</span> <span class="n">Event</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">timestamp</span><span class="p">(),</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;in&#39;</span><span class="p">)})</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>func</strong> (<em>function</em>) &#8211; Mapper function</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New collection containing mapped events.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Get max</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Maximum value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Get mean</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Mean value (grrr!).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.median">
<code class="descname">median</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Get median</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Median value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Get min</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Minimum value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.percentile">
<code class="descname">percentile</code><span class="sig-paren">(</span><em>perc</em>, <em>field_path</em>, <em>method='linear'</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets percentile perc within the Collection. This works the same
way as numpy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>perc</strong> (<em>int</em>) &#8211; The percentile (should be between 0 and 100)</li>
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>method</strong> (<em>str, optional</em>) &#8211; <p>Specifies the interpolation method to use when the desired
percentile lies between two data points. Options are:</p>
<p>linear: i + (j - i) * fraction, where fraction is the fractional
part of the index surrounded by i and j.</p>
<p>lower: i</p>
<p>higher: j</p>
<p>nearest: i or j whichever is nearest</p>
<p>midpoint: (i + j) / 2</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The percentile.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>num</em>, <em>field_path=None</em>, <em>method='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets num quantiles within the Collection</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num</strong> (<em>Number of quantiles to divide the Collection into.</em>) &#8211; Description</li>
<li><strong>field_path</strong> (<em>None, optional</em>) &#8211; The field to return as the quantile. If not set, defaults
to &#8216;value.&#8217;</li>
<li><strong>method</strong> (<em>str, optional</em>) &#8211; <p>Specifies the interpolation method to use when the desired
percentile lies between two data points. Options are:</p>
<p>linear: i + (j - i) * fraction, where fraction is the fractional
part of the index surrounded by i and j.</p>
<p>lower: i</p>
<p>higher: j</p>
<p>nearest: i or j whichever is nearest</p>
<p>midpoint: (i + j) / 2</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An array of quantiles</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.range">
<code class="descname">range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.range" title="Permalink to this definition">¶</a></dt>
<dd><p>From the range of times, or Indexes within the TimeSeries, return
the extents of the Collection/TimeSeries as a TimeRange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Extents as time range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.collection.Collection.same">
<em class="property">static </em><code class="descname">same</code><span class="sig-paren">(</span><em>coll1</em>, <em>coll2</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Test to see if the collections <em>have the same values</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coll1</strong> (<a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection"><em>Collection</em></a>) &#8211; A collection.</li>
<li><strong>coll2</strong> (<a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection"><em>Collection</em></a>) &#8211; Another collection.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if same values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.set_events">
<code class="descname">set_events</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.set_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new Collection from this one and set the internal
list of events</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>events</strong> (<em>list or pyrsistent.pvector</em>) &#8211; A list of events</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns a new collection with the event list set to the
everts arg</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">CollectionException</span></code> &#8211; Raised if wrong arg type.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.size">
<code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of items in collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Number of items in collection</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.size_valid">
<code class="descname">size_valid</code><span class="sig-paren">(</span><em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.size_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of valid items in this collection.</p>
<p>Uses the fieldSpec to look up values in all events.
It then counts the number that are considered valid,
i.e. are not NaN, undefined or null.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Number of valid &lt;field_path&gt; values in all of the Events.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a slice of events within the Collection, returns a new
Collection representing a portion of this TimeSeries from begin up to
but not including end. Uses typical python [slice:syntax].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>begin</strong> (<em>int</em>) &#8211; Slice begin.</li>
<li><strong>end</strong> (<em>int</em>) &#8211; Slice end.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New collection with sliced payload.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>field_path</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the Collection using the value referenced by field_path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New collection of sorted values.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.sort_by_time">
<code class="descname">sort_by_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.sort_by_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this collection after making sure
that all of the events are sorted by timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of this collection with the events chronologically
sorted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.stdev">
<code class="descname">stdev</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Get std dev</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Standard deviation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get sum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Summed value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the collection as json object.</p>
<p>This is actually like json.loads(s) - produces the
actual vanilla data structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A thawed list of Event objects.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Retruns the collection as a string, useful for serialization.</p>
<p>In JS land, this is synonymous with __str__ or __unicode__</p>
<p>Use custom object encoder because this is a list of Event* objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String representation of this object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.collection.Collection.type">
<code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.collection.Collection.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Event object type.</p>
<p>The class of the type of events in this collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The class (not instance) of the type of events.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypond.event">
<span id="pypond-event-module"></span><h2>pypond.event module<a class="headerlink" href="#module-pypond.event" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the Pond Event classes.</p>
<p><a class="reference external" href="http://software.es.net/pond/#/events">http://software.es.net/pond/#/events</a></p>
<dl class="class">
<dt id="pypond.event.Event">
<em class="property">class </em><code class="descclassname">pypond.event.</code><code class="descname">Event</code><span class="sig-paren">(</span><em>instance_or_time</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.event.EventBase" title="pypond.event.EventBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.event.EventBase</span></code></a></p>
<p>A generic event. This represents a data object at a single timestamp,
supplied at initialization.</p>
<p>The timestamp may be a python date object, datetime object, or
ms since UNIX epoch. It is stored internally as a datetime object.</p>
<p>The data may be any type.</p>
<p>Asking the Event object for the timestamp returns an integer copy
of the number of ms since the UNIX epoch. There&#8217;s no method on
the Event object to mutate the Event timestamp after it is created.</p>
<p>The creation of an Event is done by combining two parts:
the timestamp (or time range, or Index...) and the data.</p>
<p>To construct you specify the timestamp as either:</p>
<ul class="simple">
<li>a python date or datetime object</li>
<li>millisecond timestamp: the number of ms since the UNIX epoch</li>
</ul>
<p>To specify the data you can supply either:</p>
<ul class="simple">
<li>a python dict</li>
<li>a pyrsistent.PMap created with pyrsistent.freeze(), or</li>
<li>a simple type such as an integer. In the case of the simple type
this is a shorthand for supplying {&#8220;value&#8221;: v}.</li>
</ul>
<p>If supplying a PMap for either of the args (rather than supplying
a python dict and letting the Event class handle it which is
preferred), create it with freeze() and not pmap(). This is because
any nested dicts must similarly be made immutable and pmap() will
only freeze the &#8220;outer&#8221; dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>instance_or_time</strong> (<em>Event, pyrsistent.PMap, int, datetime.datetime</em>) &#8211; An event for copy constructor, a fully formed and formatted
immutable data payload, or an int (epoch ms) or a
datetime.datetime object to create a timestamp from.</li>
<li><strong>data</strong> (<em>None, optional</em>) &#8211; Could be dict/PMap/int/float/str to use for data payload.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="pypond.event.Event.avg">
<em class="property">static </em><code class="descname">avg</code><span class="sig-paren">(</span><em>events</em>, <em>field_spec=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.avg" title="Permalink to this definition">¶</a></dt>
<dd><p>combine() called with a averaging function as a reducer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>events</strong> (<em>list</em>) &#8211; A list of Event objects</li>
<li><strong>field_spec</strong> (<em>list, str, None, optional</em>) &#8211; Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.  If None, all columns
will be operated on.</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list containing the averaged events.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>The begin time of this Event, which will be just the timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.collapse">
<code class="descname">collapse</code><span class="sig-paren">(</span><em>field_spec_list</em>, <em>name</em>, <em>reducer</em>, <em>append=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Collapses this event&#8217;s columns, represented by the fieldSpecList
into a single column. The collapsing itself is done with the reducer
function. Optionally the collapsed column could be appended to the
existing columns, or replace them (the default).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec_list</strong> (<em>list</em>) &#8211; List of columns to collapse. If you need to retrieve deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].</li>
<li><strong>name</strong> (<em>str</em>) &#8211; Name of new column with collapsed data.</li>
<li><strong>reducer</strong> (<em>function</em>) &#8211; Function to pass to reducer.</li>
<li><strong>append</strong> (<em>bool, optional</em>) &#8211; Set True to add new column to existing data dict, False to create
a new Event with just the collapsed data.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New event object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.combine">
<em class="property">static </em><code class="descname">combine</code><span class="sig-paren">(</span><em>events</em>, <em>field_spec</em>, <em>reducer</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines multiple <cite>events</cite> together into a new array of events, one
for each time/index/timerange of the source events. The list of
events may be specified as an array or <cite>Immutable.List</cite>. Combining acts
on the fields specified in the <cite>fieldSpec</cite> and uses the reducer
function to take the multiple values and reducer them down to one.</p>
<p>The return result will be an of the same form as the input. If you
pass in an array of events, you will get an array of events back. If
you pass an <cite>Immutable.List</cite> of events then you will get an
<cite>Immutable.List</cite> of events back.</p>
<p>This is the general version of <cite>Event.sum()</cite> and <cite>Event.avg()</cite>. If those
common use cases are what you want, just use those functions. If you
want to specify your own reducer you can use this function.</p>
<p>See also: <cite>TimeSeries.timeSeriesListSum()</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>events</strong> (<em>list</em>) &#8211; List of Event objects</li>
<li><strong>field_spec</strong> (<em>string, list</em>) &#8211; Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.  If None, all columns
will be operated on.</li>
<li><strong>reducer</strong> (<em>function</em>) &#8211; Reducer function to apply to column data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">List of new events</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">list</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">EventException</span></code> &#8211; Raised if illegal input is received.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.end" title="Permalink to this definition">¶</a></dt>
<dd><p>The end time of this Event, which will be just the timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.is_duplicate">
<em class="property">static </em><code class="descname">is_duplicate</code><span class="sig-paren">(</span><em>event1</em>, <em>event2</em>, <em>ignore_values=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.is_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the two supplied events are duplicates
of each other. By default, duplicated means that the
timestamps are the same. This is the case with incoming events
where the second event is either known to be the same (but
duplicate) of the first, or supersedes the first. You can
also pass in false for ignoreValues and get a full
compare.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>event1</strong> (<em>Event, IndexedEvent or TimeSeriesEvent</em>) &#8211; One of the event variants.</li>
<li><strong>event2</strong> (<em>Event, IndexedEvent or TimeSeriesEvent</em>) &#8211; One of the event variants.</li>
<li><strong>ignore_values</strong> (<em>bool, optional</em>) &#8211; If set to True, the values of the events will be compared
as well. The default means only the type and key will
be compared.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Description</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">TYPE</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.is_valid_value">
<em class="property">static </em><code class="descname">is_valid_value</code><span class="sig-paren">(</span><em>event</em>, <em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.is_valid_value" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as Event.value() only it will return false if the
value is either undefined, NaN or Null.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>event</strong> (<a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event"><em>Event</em></a>) &#8211; An event.</li>
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Return false if undefined, NaN, or None.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.key">
<code class="descname">key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return timestamp as ms since epoch</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ms since epoch.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.map">
<em class="property">static </em><code class="descname">map</code><span class="sig-paren">(</span><em>events</em>, <em>field_spec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps a list of events according to the selection
specification in. The spec may be a single
field name, a list of field names, or a function
that takes an event and returns a key/value pair.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="mi">1</span>

        <span class="ow">in</span>   <span class="n">out</span>
 <span class="mi">3</span><span class="n">am</span>    <span class="mi">1</span>    <span class="mi">2</span>
 <span class="mi">4</span><span class="n">am</span>    <span class="mi">3</span>    <span class="mi">4</span>

<span class="n">result</span> <span class="o">-&gt;</span>  <span class="p">{</span><span class="ow">in</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>events</strong> (<em>list</em>) &#8211; A list of events</li>
<li><strong>field_spec</strong> (<em>str, list, func or None, optional</em>) &#8211; <p>Column or columns to map. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this. If None, then
all columns will be mapped.</p>
<p>If field_spec is a function, the function should return a
dict. The keys will be come the &#8220;column names&#8221; that will
be used in the dict that is returned.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dict of mapped columns/values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.map_reduce">
<em class="property">static </em><code class="descname">map_reduce</code><span class="sig-paren">(</span><em>events</em>, <em>field_spec</em>, <em>reducer</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.map_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>map and reduce</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>events</strong> (<em>list</em>) &#8211; A list of events</li>
<li><strong>field_spec</strong> (<em>str, list, func or None, optional</em>) &#8211; Column or columns to map. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this. If None, then
all columns will be mapped.</li>
<li><strong>reducer</strong> (<em>function</em>) &#8211; The reducer function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dict as returned by reduce()</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.merge">
<em class="property">static </em><code class="descname">merge</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges multiple <cite>events</cite> together into a new array of events, one
for each time/index/timerange of the source events. Merging is done on
the data of each event. Values from later events in the list overwrite
early values if fields conflict.</p>
<p>Common use cases:</p>
<ul class="simple">
<li>append events of different timestamps</li>
<li>merge in events with one field to events with another</li>
<li>merge in events that supersede the previous events</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>events</strong> (<em>list</em>) &#8211; A list of a homogenous kind of event.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of the merged events.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">EventException</span></code> &#8211; Raised if event list is not homogenous.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.reduce">
<em class="property">static </em><code class="descname">reduce</code><span class="sig-paren">(</span><em>mapped</em>, <em>reducer</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of events and a reducer function and returns
a new Event with the result, for each column. The reducer is
of the form</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="nb">sum</span><span class="p">(</span><span class="n">valueList</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">calcValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mapped</strong> (<em>dict</em>) &#8211; Dict as produced by map()</li>
<li><strong>reducer</strong> (<em>function</em>) &#8211; The reducer function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dict of reduced values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.same">
<em class="property">static </em><code class="descname">same</code><span class="sig-paren">(</span><em>event1</em>, <em>event2</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Different name for is() which is an invalid method name.
Different than __eq__ - see Object.is() JS documentation.</p>
<p>Check if the two objects are the same.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>event1</strong> (<a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event"><em>Event</em></a>) &#8211; An event.</li>
<li><strong>event2</strong> (<a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event"><em>Event</em></a>) &#8211; Another event.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns True if the event payloads is the same.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.selector">
<em class="property">static </em><code class="descname">selector</code><span class="sig-paren">(</span><em>event</em>, <em>field_spec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.selector" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to select specific fields of an event using
a fieldSpec and return a new event with just those fields.</p>
<p>The fieldSpec currently can be:</p>
<ul class="simple">
<li>A single field name</li>
<li>An list of field names</li>
</ul>
<p>The function returns a new event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>event</strong> (<a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event"><em>Event</em></a>) &#8211; Event to pull from.</li>
<li><strong>field_spec</strong> (<em>str, list, tuple, None, optional</em>) &#8211; Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.  If None, the default
column &#8216;value&#8217; will be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new event object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data portion of the event and returns a new Event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; New data payload for this event object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A new event object.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.Event.sum">
<em class="property">static </em><code class="descname">sum</code><span class="sig-paren">(</span><em>events</em>, <em>field_spec=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>combine() called with a summing function as a reducer. All
of the events need to have the same timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>events</strong> (<em>list</em>) &#8211; A list of Event objects</li>
<li><strong>field_spec</strong> (<em>list, str, None, optional</em>) &#8211; Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.  If None, all columns
will be operated on.</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list containing the summed events.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">list</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">EventException</span></code> &#8211; Raised on mismatching timestamps.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.timestamp">
<code class="descname">timestamp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>The timestamp of this data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.timestamp_as_local_string">
<code class="descname">timestamp_as_local_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.timestamp_as_local_string" title="Permalink to this definition">¶</a></dt>
<dd><p>The timestamp of this data, in Local time, as a formatted string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Formatted data string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.timestamp_as_utc_string">
<code class="descname">timestamp_as_utc_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.timestamp_as_utc_string" title="Permalink to this definition">¶</a></dt>
<dd><p>The timestamp of this data, in UTC time, as a formatted string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Formatted data string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Event as a JSON object, essentially</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">time</span><span class="p">:</span> <span class="n">ms_since_epoch</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="o">...</span><span class="p">}}</span>
</pre></div>
</div>
<p>This is actually like json.loads(s) - produces the
actual data structure from the object internal data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">time/data keys</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.to_point">
<code class="descname">to_point</code><span class="sig-paren">(</span><em>cols=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a flat array starting with the timestamp, followed by the values.
Can be given an optional list of columns so the returned list will
have the values in order. Primarily for the TimeSeries wire format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cols</strong> (<em>list, optional</em>) &#8211; List of data columns to order the data points in so the
TimeSeries wire format lines up correctly. If not specified,
the points will be whatever order that dict.values() decides
to return it in.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Epoch ms followed by points.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.Event.type">
<code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.Event.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type of the event object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Return the class of thise event type.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">class</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypond.event.EventBase">
<em class="property">class </em><code class="descclassname">pypond.event.</code><code class="descname">EventBase</code><span class="sig-paren">(</span><em>underscore_d</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.bases.PypondBase" title="pypond.bases.PypondBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.bases.PypondBase</span></code></a></p>
<p>Common code for the event classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>underscore_d</strong> (<em>pyrsistent.pmap</em>) &#8211; Immutable dict-like object containing the payload for the
events.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.event.EventBase.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>equality operator. need this to be able to check if
the event_list in a collection is the same as another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event"><em>Event</em></a>) &#8211; Event object for == comparison.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if other event has same payload.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>call to_string()</p>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract, override in subclass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; Needs to be implemented in subclasses.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.data">
<code class="descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct access to the event data. The result will be an pyrsistent.pmap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The immutable data payload.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyrsistent.pmap</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.EventBase.data_from_arg">
<em class="property">static </em><code class="descname">data_from_arg</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.data_from_arg" title="Permalink to this definition">¶</a></dt>
<dd><p>extract data from a constructor arg and make immutable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg</strong> (<em>dict, pmap, int, float, str</em>) &#8211; Data payloas as passed to one of the constructors. If dict or
pmap, that is used as the data payload, if other value, then
presumed to be a simple payload of {&#8216;value&#8217;: arg}.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Immutable dict-like object</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">pyrsistent.pmap</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">EventException</span></code> &#8211; Raised on bad arg input.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.end" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract, override in subclass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; Needs to be implemented in subclasses.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get specific data out of the Event. The data will be converted
to a js object. You can use a fieldSpec to address deep data.
A fieldSpec could be &#8220;a.b&#8221; or it could be [&#8216;a&#8217;, &#8216;b&#8217;]. Favor
the list version please.</p>
<p>The field spec can have an arbitrary number of &#8220;parts.&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Type depends on underyling data</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">various</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.EventBase.index_from_args">
<em class="property">static </em><code class="descname">index_from_args</code><span class="sig-paren">(</span><em>instance_or_index</em>, <em>utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.index_from_args" title="Permalink to this definition">¶</a></dt>
<dd><p>create Index from a constructor arg.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>instance_or_index</strong> (<em>Index or str</em>) &#8211; Index value as passed to a constructor</li>
<li><strong>utc</strong> (<em>bool, optional</em>) &#8211; Use utc time internally, please don&#8217;t not do this.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New Index object from args.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#pypond.index.Index" title="pypond.index.Index">Index</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">EventException</span></code> &#8211; Raised on invalid arg.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.stringify">
<code class="descname">stringify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.stringify" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a json string of the internal data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String representation of this object&#8217;s internal data.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.EventBase.timerange_from_arg">
<em class="property">static </em><code class="descname">timerange_from_arg</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.timerange_from_arg" title="Permalink to this definition">¶</a></dt>
<dd><p>create TimeRange from a constructor arg.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg</strong> (<em>list, tuple, pvector or TimeRange</em>) &#8211; Time value as passed to one of the constructors.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New TimeRange instance from args</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">EventException</span></code> &#8211; Raised on invalid arg.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.timestamp">
<code class="descname">timestamp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract, override in subclass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; Needs to be implemented in subclasses.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.event.EventBase.timestamp_from_arg">
<em class="property">static </em><code class="descname">timestamp_from_arg</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.timestamp_from_arg" title="Permalink to this definition">¶</a></dt>
<dd><p>extract timestamp from a constructor arg.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg</strong> (<em>int or datetime.datetime</em>) &#8211; Time value as passed to one of the constructors</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Datetime object that has been sanitized</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">EventException</span></code> &#8211; Does not accept unaware datetime objects.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract, override in subclasses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; Needs to be implemented in subclasses.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Retruns the Event as a string, useful for serialization.
It&#8217;s a JSON string of the whole object.</p>
<p>In JS land, this is synonymous with __str__ or __unicode__</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String representation of this object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pypond.event.EventBase.ts">
<code class="descname">ts</code><a class="headerlink" href="#pypond.event.EventBase.ts" title="Permalink to this definition">¶</a></dt>
<dd><p>A property to expose the datetime.datetime value returned
by the timestamp() method.  This is so we can support sorting
of a list of events via the following method:</p>
<blockquote>
<div>ordered = sorted(self._event_list, key=lambda x: x.ts)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Returns the value returned by timestamp()</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.event.EventBase.value">
<code class="descname">value</code><span class="sig-paren">(</span><em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.event.EventBase.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for get()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_path</strong> (<em>str, list, tuple, None</em>) &#8211; <p>Name of value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Type depends on underlying data.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">various</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypond.exceptions">
<span id="pypond-exceptions-module"></span><h2>pypond.exceptions module<a class="headerlink" href="#module-pypond.exceptions" title="Permalink to this headline">¶</a></h2>
<p>Custom exception and warning classes.</p>
<dl class="exception">
<dt id="pypond.exceptions.CollectionException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">CollectionException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.CollectionException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Collection exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.CollectionWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">CollectionWarning</code><a class="headerlink" href="#pypond.exceptions.CollectionWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Collection warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.EventException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">EventException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.EventException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Event exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.EventWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">EventWarning</code><a class="headerlink" href="#pypond.exceptions.EventWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Event warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.FilterException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">FilterException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.FilterException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Filter exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.FilterWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">FilterWarning</code><a class="headerlink" href="#pypond.exceptions.FilterWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Filter warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.FunctionException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">FunctionException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.FunctionException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Function exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.FunctionWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">FunctionWarning</code><a class="headerlink" href="#pypond.exceptions.FunctionWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Function warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.IndexException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">IndexException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.IndexException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Index exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.IndexWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">IndexWarning</code><a class="headerlink" href="#pypond.exceptions.IndexWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Index warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.PipelineException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">PipelineException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.PipelineException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Pipeline exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.PipelineIOException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">PipelineIOException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.PipelineIOException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom PipelineIO exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.PipelineIOWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">PipelineIOWarning</code><a class="headerlink" href="#pypond.exceptions.PipelineIOWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom PipelineIO warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.PipelineWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">PipelineWarning</code><a class="headerlink" href="#pypond.exceptions.PipelineWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Pipeline warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.ProcessorException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">ProcessorException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.ProcessorException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Processor exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.ProcessorWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">ProcessorWarning</code><a class="headerlink" href="#pypond.exceptions.ProcessorWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Processor warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.TimeRangeException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">TimeRangeException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.TimeRangeException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom TimeRange exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.TimeRangeWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">TimeRangeWarning</code><a class="headerlink" href="#pypond.exceptions.TimeRangeWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom TimeRange warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.TimeSeriesException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">TimeSeriesException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.TimeSeriesException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom TimeSeries exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.TimeSeriesWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">TimeSeriesWarning</code><a class="headerlink" href="#pypond.exceptions.TimeSeriesWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom TimeSeries warning</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.UtilityException">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">UtilityException</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.exceptions.UtilityException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Custom Utility exception</p>
</dd></dl>

<dl class="exception">
<dt id="pypond.exceptions.UtilityWarning">
<em class="property">exception </em><code class="descclassname">pypond.exceptions.</code><code class="descname">UtilityWarning</code><a class="headerlink" href="#pypond.exceptions.UtilityWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Custom Utility warning</p>
</dd></dl>

</div>
<div class="section" id="module-pypond.functions">
<span id="pypond-functions-module"></span><h2>pypond.functions module<a class="headerlink" href="#module-pypond.functions" title="Permalink to this headline">¶</a></h2>
<p>Functions to act as reducers/aggregators, etc.</p>
<dl class="class">
<dt id="pypond.functions.Filters">
<em class="property">class </em><code class="descclassname">pypond.functions.</code><code class="descname">Filters</code><a class="headerlink" href="#pypond.functions.Filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Filter functions to pass to aggregation function factory
methods.</p>
<p>These all control how the underlying aggregators handle missing/invalid
values.  Can pass things through (the default to all agg functions),
ignore any bad values, transform any bad values to zero, or make the
entire aggregation fail if there are any bad values.</p>
<dl class="staticmethod">
<dt id="pypond.functions.Filters.ignore_missing">
<em class="property">static </em><code class="descname">ignore_missing</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Filters.ignore_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull out the bad values resulting in a shorter array.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Filters.keep_missing">
<em class="property">static </em><code class="descname">keep_missing</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Filters.keep_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>no-op - default</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Filters.none_if_empty">
<em class="property">static </em><code class="descname">none_if_empty</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Filters.none_if_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return none if the event list is empty. Could be used to override
the default behavior of Functions.avg(), etc</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Filters.propogate_missing">
<em class="property">static </em><code class="descname">propogate_missing</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Filters.propogate_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>It&#8217;s all bad if there are missing values - return None if so.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Filters.zero_missing">
<em class="property">static </em><code class="descname">zero_missing</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Filters.zero_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Make bad values 0 - array will be the same length.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypond.functions.Functions">
<em class="property">class </em><code class="descclassname">pypond.functions.</code><code class="descname">Functions</code><a class="headerlink" href="#pypond.functions.Functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Utility class to contain the functions.</p>
<p>The inner() function is the one that does the actual processing and
it returned by calling the outer named function.  Previously one would
pass Functions.sum to an aggregation or reducer method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Functions</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now it is a factory to return the acutal function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Functions</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="s1">&#39;in&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The static methods in the Filters class can be passed to the outer
factory method to control how bad values are handled:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Functions</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Filters</span><span class="o">.</span><span class="n">zero_missing</span><span class="p">),</span> <span class="s1">&#39;in&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="staticmethod">
<dt id="pypond.functions.Functions.avg">
<em class="property">static </em><code class="descname">avg</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.avg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.count">
<em class="property">static </em><code class="descname">count</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.difference">
<em class="property">static </em><code class="descname">difference</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.difference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.first">
<em class="property">static </em><code class="descname">first</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.first" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.keep">
<em class="property">static </em><code class="descname">keep</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.keep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.last">
<em class="property">static </em><code class="descname">last</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.last" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.max">
<em class="property">static </em><code class="descname">max</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.median">
<em class="property">static </em><code class="descname">median</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.median" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.min">
<em class="property">static </em><code class="descname">min</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.percentile">
<em class="property">static </em><code class="descname">percentile</code><span class="sig-paren">(</span><em>perc</em>, <em>method='linear'</em>, <em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.percentile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.stddev">
<em class="property">static </em><code class="descname">stddev</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.stddev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pypond.functions.Functions.sum">
<em class="property">static </em><code class="descname">sum</code><span class="sig-paren">(</span><em>flt=&lt;function keep_missing&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.Functions.sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pypond.functions.f_check">
<code class="descclassname">pypond.functions.</code><code class="descname">f_check</code><span class="sig-paren">(</span><em>flt</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.functions.f_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the default filter for aggregation operations when no
filter is specified. When one is, make sure that it is a
valid filter.</p>
</dd></dl>

</div>
<div class="section" id="module-pypond.index">
<span id="pypond-index-module"></span><h2>pypond.index module<a class="headerlink" href="#module-pypond.index" title="Permalink to this headline">¶</a></h2>
<p>Implementation of Pond Index class.</p>
<p><a class="reference external" href="http://software.es.net/pond/#/index">http://software.es.net/pond/#/index</a></p>
<dl class="class">
<dt id="pypond.index.Index">
<em class="property">class </em><code class="descclassname">pypond.index.</code><code class="descname">Index</code><span class="sig-paren">(</span><em>s</em>, <em>utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.bases.PypondBase" title="pypond.bases.PypondBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.bases.PypondBase</span></code></a></p>
<p>An index that represents as a string a range of time. That range may either
be in UTC or local time. UTC is the default.</p>
<p>The actual derived timerange can be found using asRange(). This will return
a TimeRange instance.</p>
<p>The original string representation can be found with toString(). A nice
version for date based indexes (e.g. 2015-03) can be generated with
toNiceString(format) (e.g. March, 2015).</p>
<p>The index string arg will may be of two forms:</p>
<ul class="simple">
<li>2015-07-14  (day)</li>
<li>2015-07     (month)</li>
<li>2015        (year)</li>
</ul>
<p>or:</p>
<ul class="simple">
<li>1d-278      (range, in n x days, hours, minutes or seconds)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>str</em>) &#8211; The index string in one of the aforementioned formats.</li>
<li><strong>utc</strong> (<em>bool, optional</em>) &#8211; Index interpreted as UTC or localtime. Please don&#8217;t set this to false
since non-UTC times are the devil.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">IndexException</span></code> &#8211; Raised if arg s could not be translated into a valid timerange/index.</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.index.Index.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>call to_string()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String representation of the object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.as_string">
<code class="descname">as_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.as_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for to_string()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The index string as previously outlined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.as_timerange">
<code class="descname">as_timerange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.as_timerange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Index as a TimeRange</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The underlying time range object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns start date of the index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Start date of the index.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns end date of the index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">End date of the index.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.index.Index.get_daily_index_string">
<em class="property">static </em><code class="descname">get_daily_index_string</code><span class="sig-paren">(</span><em>date</em>, <em>utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.get_daily_index_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an index string with day granularity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>date</strong> (<em>datetime.datetime</em>) &#8211; An aware UTC datetime object</li>
<li><strong>utc</strong> (<em>bool, optional</em>) &#8211; Render the index in local time this is used for display purposes
to render charts in a localized way.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The formatted index string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.index.Index.get_index_string">
<em class="property">static </em><code class="descname">get_index_string</code><span class="sig-paren">(</span><em>win</em>, <em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.get_index_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index string given an index prefix and a datetime
object. Example usage follows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dtime</span> <span class="o">=</span> <span class="n">aware_dt_from_args</span><span class="p">(</span>
    <span class="nb">dict</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2015</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">22</span><span class="p">))</span>

<span class="n">idx_str</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">get_index_string</span><span class="p">(</span><span class="s1">&#39;5m&#39;</span><span class="p">,</span> <span class="n">dtime</span><span class="p">)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">idx_str</span><span class="p">,</span> <span class="s1">&#39;5m-4754394&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>previously: Generator.bucketIndex</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>win</strong> (<em>str</em>) &#8211; Prefix of the index string.</li>
<li><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; Datetime to generate index string from.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The index string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.index.Index.get_index_string_list">
<em class="property">static </em><code class="descname">get_index_string_list</code><span class="sig-paren">(</span><em>win</em>, <em>timerange</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.get_index_string_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the time range, return a list of strings of index values
every &lt;prefix&gt; tick. Example usage follows (from test suite).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dtime_1</span> <span class="o">=</span> <span class="n">aware_dt_from_args</span><span class="p">(</span>
<span class="nb">dict</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2015</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="n">dtime_2</span> <span class="o">=</span> <span class="n">aware_dt_from_args</span><span class="p">(</span>
    <span class="nb">dict</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2015</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="mi">29</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">59</span><span class="p">))</span>

<span class="n">idx_list</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">get_index_string_list</span><span class="p">(</span><span class="s1">&#39;5m&#39;</span><span class="p">,</span> <span class="n">TimeRange</span><span class="p">(</span><span class="n">dtime_1</span><span class="p">,</span> <span class="n">dtime_2</span><span class="p">))</span>

<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_list</span><span class="p">),</span> <span class="mi">12</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">idx_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;5m-4754394&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">idx_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;5m-4754405&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>previously: Generator.bucketIndexList</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>win</strong> (<em>str</em>) &#8211; Prefix of the index string.</li>
<li><strong>timerange</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Time range object to generate index string from</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of strings of index values at every &#8220;tick&#8221; in the range
specified.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.index.Index.get_monthly_index_string">
<em class="property">static </em><code class="descname">get_monthly_index_string</code><span class="sig-paren">(</span><em>date</em>, <em>utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.get_monthly_index_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an index string with month granularity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>date</strong> (<em>datetime.datetime</em>) &#8211; An aware UTC datetime object</li>
<li><strong>utc</strong> (<em>bool, optional</em>) &#8211; Render the index in local time this is used for display purposes
to render charts in a localized way.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The formatted index string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.index.Index.get_yearly_index_string">
<em class="property">static </em><code class="descname">get_yearly_index_string</code><span class="sig-paren">(</span><em>date</em>, <em>utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.get_yearly_index_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an index string with year granularity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>date</strong> (<em>datetime.datetime</em>) &#8211; An aware UTC datetime object</li>
<li><strong>utc</strong> (<em>bool, optional</em>) &#8211; Render the index in local time this is used for display purposes
to render charts in a localized way.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The formatted index string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.range_from_index_string">
<code class="descname">range_from_index_string</code><span class="sig-paren">(</span><em>idx_str</em>, <em>is_utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.range_from_index_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the time range from the idx string.</p>
<p>The index string arg will may be of two forms:</p>
<ul class="simple">
<li>2015-07-14  (day)</li>
<li>2015-07     (month)</li>
<li>2015        (year)</li>
</ul>
<p>or:</p>
<ul class="simple">
<li>1d-278      (range, in n x days, hours, minutes or seconds)</li>
</ul>
<p>and return a TimeRange for that time. The TimeRange may be considered to be
local time or UTC time, depending on the utc flag passed in.</p>
<p>This was in src/util.js in the original project, but the only thing using
the code in that util.js was the Index class, and it makes more sense
having this as a class method and setting self._index_type makes further
regex analysis of the index unnecessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>idx_str</strong> (<em>str</em>) &#8211; The index string in one of the aformentioned formats</li>
<li><strong>is_utc</strong> (<em>bool, optional</em>) &#8211; Index interpreted as utc or localtime. Please don&#8217;t use localtime.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A time range made from the interpreted index string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">IndexException</span></code> &#8211; Raised when the string format is determined to be invalid.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Index as JSON, which will just be its string
representation</p>
<p>This is actually like json.loads(s) - produces the
actual data structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The index string as previously outlined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.to_nice_string">
<code class="descname">to_nice_string</code><span class="sig-paren">(</span><em>fmt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.to_nice_string" title="Permalink to this definition">¶</a></dt>
<dd><p>for the calendar range style Indexes, this lets you return
that calendar range as a human readable format, e.g. &#8220;June, 2014&#8221;.
The format specified is a Moment.format.</p>
<p>Originally implemented at Util.niceIndexString in the JS source,
this is just a greatly simplified version using self._index_type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fmt</strong> (<em>str, optional</em>) &#8211; User can pass in a valid strftime() format string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">FThe index text string as a formatted (strftime()) time.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.index.Index.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply returns the Index as its string</p>
<p>In JS land, this is synonymous with __str__ or __unicode__</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The index string as previously outlined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pypond.index.Index.utc">
<code class="descname">utc</code><a class="headerlink" href="#pypond.index.Index.utc" title="Permalink to this definition">¶</a></dt>
<dd><p>accessor for internal utc boolean.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.index.Index.window_duration">
<em class="property">static </em><code class="descname">window_duration</code><span class="sig-paren">(</span><em>win</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.window_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>duration in ms given a window duration string.</p>
<p>previously: Generator.getLengthFromSize.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>win</strong> (<em>str</em>) &#8211; An index string in the previously mentioned 1d-278 style format.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Duration of the index/range in ms.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.index.Index.window_position_from_date">
<em class="property">static </em><code class="descname">window_position_from_date</code><span class="sig-paren">(</span><em>win</em>, <em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.index.Index.window_position_from_date" title="Permalink to this definition">¶</a></dt>
<dd><p>window position from datetime object. Called by get_index_string_list().</p>
<p>previously: Generator.getBucketPosFromDate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>win</strong> (<em>str</em>) &#8211; Prefix if the index string.</li>
<li><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; Datetime to calculate suffix from.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The suffix for the index string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypond.indexed_event">
<span id="pypond-indexed-event-module"></span><h2>pypond.indexed_event module<a class="headerlink" href="#module-pypond.indexed_event" title="Permalink to this headline">¶</a></h2>
<p>Event with a time range specified as an index.</p>
<dl class="class">
<dt id="pypond.indexed_event.IndexedEvent">
<em class="property">class </em><code class="descclassname">pypond.indexed_event.</code><code class="descname">IndexedEvent</code><span class="sig-paren">(</span><em>instance_or_begin</em>, <em>data=None</em>, <em>utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.event.EventBase" title="pypond.event.EventBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.event.EventBase</span></code></a></p>
<p>Associates a time range specified as an index.</p>
<p>The creation of an IndexedEvent is done by combining two parts:
the Index and the data.</p>
<p>To construct you specify an Index, along with the data.</p>
<p>The index may be an Index, or a string.</p>
<dl class="docutils">
<dt>To specify the data you can supply either:</dt>
<dd><ul class="first last simple">
<li>a python dict containing key values pairs</li>
<li>an pyrsistent.pmap, or</li>
<li>a simple type such as an integer. In the case of the simple type
this is a shorthand for supplying {&#8220;value&#8221;: v}.</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>instance_or_begin</strong> (<em>Index, pyrsistent.pmap, or str.</em>) &#8211; Index for copy constructor, pmap as the fully
formed internals or a string arg to the Index class.</li>
<li><strong>data</strong> (<em>dict or pyrsistent.pmap, optional</em>) &#8211; Data payload.</li>
<li><strong>utc</strong> (<em>bool, optional</em>) &#8211; UTC or localtime to create index in. Please don&#8217;t not use UTC.
Yes, that&#8217;s a double negative.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>The begin time of this Event, which will be just the timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Datetime of the beginning of the range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.end" title="Permalink to this definition">¶</a></dt>
<dd><p>The end time of this Event, which will be just the timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Datetime of the end of the range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.index">
<code class="descname">index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Index associated with the data in this Event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The underlying index object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.index.Index" title="pypond.index.Index">Index</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.index_as_string">
<code class="descname">index_as_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.index_as_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Index as a string, same as event.index().toString().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">str &#8211; String version of the underlying Index.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">String version of the underlying index.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.key">
<code class="descname">key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index string of this object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The index of this object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.index.Index" title="pypond.index.Index">Index</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data portion of the event and returns a new IndexedEvent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>dict</em>) &#8211; The new data portion for this event object.</li>
<li><strong>data</strong> &#8211; The new data payload for this event object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">IndexedEvent - a new IndexedEvent object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new indexed event with the provided payload.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.indexed_event.IndexedEvent" title="pypond.indexed_event.IndexedEvent">IndexedEvent</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.timerange">
<code class="descname">timerange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.timerange" title="Permalink to this definition">¶</a></dt>
<dd><p>The TimeRange of this data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Time range from the underlying index.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.timerange_as_local_string">
<code class="descname">timerange_as_local_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.timerange_as_local_string" title="Permalink to this definition">¶</a></dt>
<dd><p>The timerange of this data, in Local time, as a string..</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Underlying TimeRange as localtime string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.timerange_as_utc_string">
<code class="descname">timerange_as_utc_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.timerange_as_utc_string" title="Permalink to this definition">¶</a></dt>
<dd><p>The timerange of this data, in UTC time, as a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Underlying TimeRange as UTC string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.timestamp">
<code class="descname">timestamp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>The timestamp of this beginning of the range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Datetime of the beginning of the range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Event as a JSON object, essentially:
{time: t, data: {key: value, ...}}</p>
<p>This is actually like json.loads(s) - produces the
actual vanilla data structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Dictionary representation of object internals.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.to_point">
<code class="descname">to_point</code><span class="sig-paren">(</span><em>cols=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a flat array starting with the timestamp, followed by the values.
Doesn&#8217;t include the groupByKey (key).</p>
<p>Can be given an optional list of columns so the returned list will
have the values in order. Primarily for the TimeSeries wire format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cols</strong> (<em>list, optional</em>) &#8211; List of columns to order the points in so the TimeSeries
wire format is rendered corectly.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Epoch ms followed by points.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.indexed_event.IndexedEvent.type">
<code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.indexed_event.IndexedEvent.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the class of this event type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The class of this event type.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">class</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypond.pipeline">
<span id="pypond-pipeline-module"></span><h2>pypond.pipeline module<a class="headerlink" href="#module-pypond.pipeline" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the Pond Pipeline classes.</p>
<p><a class="reference external" href="http://software.es.net/pond/#/pipeline">http://software.es.net/pond/#/pipeline</a></p>
<dl class="class">
<dt id="pypond.pipeline.Pipeline">
<em class="property">class </em><code class="descclassname">pypond.pipeline.</code><code class="descname">Pipeline</code><span class="sig-paren">(</span><em>arg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.bases.PypondBase" title="pypond.bases.PypondBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.bases.PypondBase</span></code></a></p>
<p>Build a new Pipeline.</p>
<p>A pipeline manages a processing chain, for either batch or stream processing
of collection data.</p>
<p>The argument may be either:</p>
<ul class="simple">
<li>a Pipeline (copy ctor)</li>
<li>a pyrsistent.PMap in which case the internal state will be constructed from the map.</li>
</ul>
<p>Usually you would initialize a Pipeline using the factory function,
rather than this object directly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg</strong> (<em>Pipeline, PMap, None</em>) &#8211; See above.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.pipeline.Pipeline.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the incoming result from the processor callback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arg1</strong> (<em>str</em>) &#8211; Collection key string.</li>
<li><strong>arg2</strong> (<em>Collection or str</em>) &#8211; Generally the incoming collection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.aggregate">
<code class="descname">aggregate</code><span class="sig-paren">(</span><em>fields</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the current Pipeline windowing and grouping
state to build collections of events and aggregate them.</p>
<p>IndexedEvents will be emitted out of the aggregator based
on the <cite>emitOn</cite> state of the Pipeline.</p>
<p>To specify what part of the incoming events should
be aggregated together you specify a <cite>fields</cite>
object. This is a map from fieldName to operator.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">uin</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>

<span class="p">(</span>
    <span class="n">Pipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">from_source</span><span class="p">(</span><span class="n">uin</span><span class="p">)</span>
    <span class="o">.</span><span class="n">window_by</span><span class="p">(</span><span class="s1">&#39;1h&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">emit_on</span><span class="p">(</span><span class="s1">&#39;eachEvent&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s1">&#39;in_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
            <span class="s1">&#39;out_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()}</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">EventOut</span><span class="p">,</span> <span class="n">cback</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fields</strong> (<em>dict</em>) &#8211; Fields and operators to be aggregated. Deep fields may be
indicated by using this.style.notation. As in the above
example, they fields.keys() are the names of the new
columns to be created (or an old one to be overwritten),
and the value is another dict - the key is the existing
column and the value is the function to apply to it when
creating the new column.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>field_spec=None</em>, <em>window='5m'</em>, <em>method='linear'</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align entry point</p>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.as_events">
<code class="descname">as_events</code><span class="sig-paren">(</span><em>options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.as_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts incoming TimeRangeEvents or IndexedEvents to
Events. This is helpful since some processors will
emit TimeRangeEvents or IndexedEvents, which may be
unsuitable for some applications.</p>
<p>There are three options:</p>
<ol class="arabic simple">
<li>use the beginning time (options = Options(alignment=&#8217;lag&#8217;)</li>
<li>use the center time (options = Options(alignment=&#8217;center&#8217;)</li>
<li>use the end time (options = Options(alignment=&#8217;lead&#8217;)</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>options</strong> (<a class="reference internal" href="#pypond.util.Options" title="pypond.util.Options"><em>Options</em></a>) &#8211; The options, see above.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.as_indexed_events">
<code class="descname">as_indexed_events</code><span class="sig-paren">(</span><em>options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.as_indexed_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts incoming Events to IndexedEvents.</p>
<p>Note: It isn&#8217;t possible to convert TimeRangeEvents to IndexedEvents.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>options</strong> (<a class="reference internal" href="#pypond.util.Options" title="pypond.util.Options"><em>Options</em></a>) &#8211; Contains the conversion options. In this case, the duration string
of the Index is expected. Must contain the key &#8216;duration&#8217; and the
duration string is of the form &#8220;1h&#8221; for one hour, &#8220;30s&#8221; for 30
seconds and so on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Description</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">TYPE</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.as_time_range_events">
<code class="descname">as_time_range_events</code><span class="sig-paren">(</span><em>options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.as_time_range_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts incoming Events or IndexedEvents to TimeRangeEvents.</p>
<p>There are three option for alignment:</p>
<ol class="arabic simple">
<li>time range will be in front of the timestamp - ie:
options = Options(alignment=&#8217;front&#8217;)</li>
<li>time range will be centered on the timestamp - ie:
options = Options(alignment=&#8217;center&#8217;)</li>
<li>time range will be positoned behind the timestamp - ie:
options = Options(alignment=&#8217;behind&#8217;)</li>
</ol>
<p>The duration is of the form &#8220;1h&#8221; for one hour, &#8220;30s&#8221; for 30 seconds and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>options</strong> (<em>dict</em>) &#8211; Args to add to Options - duration and alignment.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.clear_group_by">
<code class="descname">clear_group_by</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.clear_group_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the grouping from the pipeline. In other words
recombine the events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.clear_results">
<code class="descname">clear_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.clear_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the result state of this Pipeline instance.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.clear_window">
<code class="descname">clear_window</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.clear_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove windowing from the Pipeline. This will
return the pipeline to no window grouping. This is
useful if you have first done some aggregation by
some window size and then wish to collect together
the all resulting events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.collapse">
<code class="descname">collapse</code><span class="sig-paren">(</span><em>field_spec_list</em>, <em>name</em>, <em>reducer</em>, <em>append=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Collapse a subset of columns using a reducer function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec_list</strong> (<em>list</em>) &#8211; List of columns to collapse. If you need to retrieve deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].</li>
<li><strong>name</strong> (<em>string</em>) &#8211; The resulting output column&#8217;s name.</li>
<li><strong>reducer</strong> (<em>function</em>) &#8211; Function to use to do the reduction.</li>
<li><strong>append</strong> (<em>bool</em>) &#8211; Add the new column to the existing ones, or replace them.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Pipeline.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>observer</em>, <em>force=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the count of events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>observer</strong> (<em>function</em>) &#8211; The callback function. This function will be passed collection.size(),
window_key, group_by_key) as args.</li>
<li><strong>force</strong> (<em>bool, optional</em>) &#8211; Flush at the end of processing batch events, output again with possibly
partial result</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Pipeline.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.emit_on">
<code class="descname">emit_on</code><span class="sig-paren">(</span><em>trigger</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.emit_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the condition under which an accumulated collection will
be emitted. If specified before an aggregation this will control
when the resulting event will be emitted relative to the
window accumulation. Current options are:</p>
<ul class="simple">
<li>to emit on every event, or</li>
<li>just when the collection is complete, or</li>
<li>when a flush signal is received, either manually calling done(),
or at the end of a bounded source.</li>
</ul>
<p>The strings indicating how to trigger how a Collection should
be emitted - can be:</p>
<ul class="simple">
<li>&#8220;eachEvent&#8221; - when a new event comes in, all currently maintained
collections will emit their result.</li>
<li>&#8220;discard&#8221; - when a collection is to be discarded, first it will
emit. But only then.</li>
<li>&#8220;flush&#8221; - when a flush signal is received.</li>
</ul>
<p>The difference will depend on the output you want, how often
you want to get updated, and if you need to get a partial state.
There&#8217;s currently no support for late data or watermarks. If an
event passes comes in after a collection window, that collection
is considered finished.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trigger</strong> (<em>string</em>) &#8211; See above</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.fill">
<code class="descname">fill</code><span class="sig-paren">(</span><em>field_spec=None</em>, <em>method='zero'</em>, <em>fill_limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the data in this timeseries and &#8220;fill&#8221; any missing
or invalid values. This could be setting None values to zero
so mathematical operations will succeed, interpolate a new
value, or pad with the previously given value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.</p>
<p>If None, the default column field &#8216;value&#8217; will be used.</p>
</li>
<li><strong>method</strong> (<em>str, optional</em>) &#8211; Filling method: zero | linear | pad</li>
<li><strong>fill_limit</strong> (<em>None, optional</em>) &#8211; Set a limit on the number of consecutive events will be filled
before it starts returning invalid values. For linear fill,
no filling will happen if the limit is reached before a valid
value is found.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Pipeline.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the event stream using an operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>op</strong> (<em>function</em>) &#8211; A function that returns True or False</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.first">
<code class="descname">first</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first processor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An pipeline processor.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pypond.processor.html#pypond.processor.base.Processor" title="pypond.processor.base.Processor">Processor</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.from_source">
<code class="descname">from_source</code><span class="sig-paren">(</span><em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.from_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Note: originally named from() in JS code.</p>
<p>The source to get events from. The source needs to be able to
iterate its events using <cite>for..of</cite> loop for bounded Ins, or
be able to emit() for unbounded Ins. The actual batch, or stream
connection occurs when an output is defined with <cite>to()</cite>.</p>
<p>Pipelines can be chained together since a source may be another
Pipeline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src</strong> (<em>Bounded, Stream or Pipeline</em>) &#8211; The source for the Pipeline, or another Pipeline.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.get_emit_on">
<code class="descname">get_emit_on</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.get_emit_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the emit on (eachEvent, etc).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The emit on string (discards, flush, etc).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.get_group_by">
<code class="descname">get_group_by</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.get_group_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the group by callback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Returns the group by function.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">function</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.get_utc">
<code class="descname">get_utc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.get_utc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the UTC state..</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">In UTC or not.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.get_window_duration">
<code class="descname">get_window_duration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.get_window_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the window duration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A formatted window duration.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.get_window_type">
<code class="descname">get_window_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.get_window_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the window type (global, etc).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The window type.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.group_by">
<code class="descname">group_by</code><span class="sig-paren">(</span><em>key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.group_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a new groupBy expression. Returns a new Pipeline.</p>
<p>Grouping is a state set on the Pipeline. Operations downstream
of the group specification will use that state. For example, an
aggregation would occur over any grouping specified.</p>
<p>The key to group by. You can pass in a function that takes and
event as an arg and dynamically returns the group by key.</p>
<p>Otherwise key will be interpreted as a field_path:</p>
<ul class="simple">
<li>a single field name or deep.column.path, or</li>
<li>a array style field_path [&#8216;deep&#8217;, &#8216;column&#8217;, &#8216;path&#8217;] to a single
column.</li>
</ul>
<p>This is not a list of multiple columns, it is the path to
a single column to pull group by keys from. For example,
a column called &#8216;status&#8217; that contains the values &#8216;OK&#8217; and
&#8216;FAIL&#8217; - they key would be &#8216;status&#8217; and two collections
OK and FAIL will be generated.</p>
<p>If key is None, then the default column &#8216;value&#8217; will
be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>function, list or string</em>) &#8211; The key to group by. See above.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.input">
<code class="descname">input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.input" title="Permalink to this definition">¶</a></dt>
<dd><p>Originally called in() in JS code.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.last">
<code class="descname">last</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last processor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An pipeline processor.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pypond.processor.html#pypond.processor.base.Processor" title="pypond.processor.base.Processor">Processor</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the event stream using an operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>op</strong> (<em>function</em>) &#8211; A function that returns a new Event.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.mode">
<code class="descname">mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the pipeline mode (ie: batch, stream).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The mode.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.offset_by">
<code class="descname">offset_by</code><span class="sig-paren">(</span><em>offset_by</em>, <em>field_spec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.offset_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Processor to offset a set of fields by a value. Mostly used for
testing processor and pipeline operations with a simple operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>offset_by</strong> (<em>int, float</em>) &#8211; The amout to offset by.</li>
<li><strong>field_spec</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.</p>
<p>If None, the default &#8216;value&#8217; column will be used.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The modified Pipeline.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.rate">
<code class="descname">rate</code><span class="sig-paren">(</span><em>field_spec=None</em>, <em>allow_negative=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.rate" title="Permalink to this definition">¶</a></dt>
<dd><p>derivative entry point</p>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.results_done">
<code class="descname">results_done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.results_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Set result state as done.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>field_spec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a subset of columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_spec</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.</p>
<p>If None, the default &#8216;value&#8217; column will be used.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Pipeline.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.take">
<code class="descname">take</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Take events up to the supplied limit, per key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>limit</strong> (<em>int</em>) &#8211; Integer number of events to take.</li>
<li><strong>global_flush</strong> (<em>bool, optional</em>) &#8211; If set to true (default is False) then the Taker will
send out a single .flush() event if the limit has been
exceeded and the window_type is &#8216;global.&#8217; This can be
used as a fail safe with processors that cache events
(like the Filler) to ensure all events are emitted when
the Pipeline is used in &#8216;stream&#8217; mode. This is not
needed in &#8216;batch&#8217; mode because the flush signal is sent
automatically.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Pipeline.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.to">
<code class="descname">to</code><span class="sig-paren">(</span><em>out</em>, <em>observer=None</em>, <em>options=&lt;pypond.util.Options object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.to" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the destination sink for the pipeline.</p>
<p>For a batch mode connection, i.e. one with a Bounded source,
the output is connected to a clone of the parts of the Pipeline dependencies
that lead to this output. This is done by a Runner. The source input is
then iterated over to process all events into the pipeline and though to the Out.</p>
<p>For stream mode connections, the output is connected and from then on
any events added to the input will be processed down the pipeline to
the out.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">do_something_with_the_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

<span class="n">timeseries</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">IN_OUT_DATA</span><span class="p">)</span>

<span class="p">(</span>
    <span class="n">Pipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">from_source</span><span class="p">(</span><span class="n">timeseries</span><span class="p">)</span>
    <span class="o">.</span><span class="n">emit_on</span><span class="p">(</span><span class="s1">&#39;flush&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">collapse</span><span class="p">([</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;out&#39;</span><span class="p">],</span> <span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">Functions</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">EventOut</span><span class="p">,</span> <span class="n">cback</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>NOTE: arg list has been changed from the ordering in the JS source
to conform to python convention.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>out</strong> (<em>EventOut, CollectionOut, etc instance</em>) &#8211; The output.</li>
<li><strong>observer</strong> (<em>function or instance</em>) &#8211; The observer.</li>
<li><strong>options</strong> (<em>Options, optional</em>) &#8211; Options.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Pipeline.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.to_event_list">
<code class="descname">to_event_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.to_event_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Directly return the results from the processor rather than
passing a callback in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Returns the _results attribute with events.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list or dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.to_keyed_collections">
<code class="descname">to_keyed_collections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.to_keyed_collections" title="Permalink to this definition">¶</a></dt>
<dd><p>Directly return the results from the processor rather than
passing a callback in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Returns the _results attribute from a Pipeline object after processing.
Will contain Collection objects.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list or dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.pipeline.Pipeline.window_by">
<code class="descname">window_by</code><span class="sig-paren">(</span><em>window_or_duration=None</em>, <em>utc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Pipeline.window_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the window, returning a new Pipeline. A new window will
have a type and duration associated with it. Current available
types are:</p>
<ul class="simple">
<li>fixed (e.g. every 5m)</li>
<li>calendar based windows (e.g. every month)</li>
</ul>
<p>Windows are a type of grouping. Typically you&#8217;d define a window
on the pipeline before doing an aggregation or some other operation
on the resulting grouped collection. You can combine window-based
grouping with key-grouping (see groupBy()).</p>
<p>There are several ways to define a window. The general format is
an options object containing a <cite>type</cite> field and a <cite>duration</cite> field.</p>
<p>Currently the only accepted type is <cite>fixed</cite>, but others are planned.
For duration, this is a duration string, for example &#8220;30s&#8221; or &#8220;1d&#8221;.
Supported are: seconds (s), minutes (m), hours (h) and days (d).</p>
<p>The argument here is either a string or an object with string
attrs type and duration. The arg can be either a window or a duration.</p>
<p>If no arg is supplied or set to None, the window_type is set
to &#8216;global&#8217; and there is no duration.</p>
<p>There is also a short-cut notation for a fixed window or a calendar
window. Simply supplying the duration string (&#8220;30s&#8221; for example) will
result in a <cite>fixed</cite> window type with the supplied duration.</p>
<p>Window <em>window_or_duration</em> may be:</p>
<ul class="simple">
<li>A fixed interval duration (see next): &#8220;fixed&#8221;</li>
<li>A calendar interval: &#8220;daily,&#8221; &#8220;monthly&#8221; or &#8220;yearly&#8221;</li>
</ul>
<p>Duration is of the form:</p>
<ul class="simple">
<li>&#8220;30s&#8221; or &#8220;1d&#8221; etc - supports seconds (s), minutes (m), hours (h),
days (d). When duration is passed as the arg, window_type is
set to &#8216;fixed&#8217;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>window_or_duration</strong> (<em>string, Capsule</em>) &#8211; See above.</li>
<li><strong>utc</strong> (<em>bool</em>) &#8211; How to render the aggregations - in UTC vs. the user&#8217;s local time.
Can not be set to False if using a fixed window size.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Pipeline.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypond.pipeline.Runner">
<em class="property">class </em><code class="descclassname">pypond.pipeline.</code><code class="descname">Runner</code><span class="sig-paren">(</span><em>pline</em>, <em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Runner" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.bases.PypondBase" title="pypond.bases.PypondBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.bases.PypondBase</span></code></a></p>
<p>A runner is used to extract the chain of processing operations
from a Pipeline given an Output. The idea here is to traverse
back up the Pipeline(s) and build an execution chain.</p>
<p>When the runner is started, events from the &#8220;in&#8221; are streamed
into the execution chain and outputed into the &#8220;out&#8221;.</p>
<p>Rebuilding in this way enables us to handle connected pipelines:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                   <span class="o">|--</span>
<span class="ow">in</span> <span class="o">--&gt;</span> <span class="n">pipeline</span> <span class="o">---.</span>
                   <span class="o">|----</span><span class="n">pipeline</span> <span class="o">---|</span> <span class="o">-&gt;</span> <span class="n">out</span>
</pre></div>
</div>
<p>The runner breaks this into the following for execution:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">_input</span>        <span class="o">-</span> <span class="n">the</span> <span class="s2">&quot;in&quot;</span> <span class="ow">or</span> <span class="n">from</span><span class="p">()</span> <span class="n">bounded</span> <span class="nb">input</span> <span class="n">of</span>
                <span class="n">the</span> <span class="n">upstream</span> <span class="n">pipeline</span>
<span class="n">_processChain</span> <span class="o">-</span> <span class="n">the</span> <span class="n">process</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">pipelines</span>
                <span class="n">leading</span> <span class="n">to</span> <span class="n">the</span> <span class="n">out</span>
<span class="n">_output</span>       <span class="o">-</span> <span class="n">the</span> <span class="n">supplied</span> <span class="n">output</span> <span class="n">destination</span> <span class="k">for</span>
                <span class="n">the</span> <span class="n">batch</span> <span class="n">process</span>
</pre></div>
</div>
<dl class="docutils">
<dt>NOTE: There&#8217;s no current way to merge multiple sources, though</dt>
<dd>a time series has a TimeSeries.merge() static method for
this purpose.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pipeline</strong> (<a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline"><em>Pipeline</em></a>) &#8211; The pipeline to run.</li>
<li><strong>output</strong> (<a class="reference internal" href="pypond.io.html#pypond.io.output.PipelineOut" title="pypond.io.output.PipelineOut"><em>PipelineOut</em></a>) &#8211; The output driving this runner</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.pipeline.Runner.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.Runner.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the runner</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>force</strong> (<em>bool, optional</em>) &#8211; force Flush at the end of the batch source</li>
<li><strong>cause any buffers to emit.</strong> (<a class="reference internal" href="#pypond.pipeline.Pipeline.to" title="pypond.pipeline.Pipeline.to"><em>to</em></a>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pypond.pipeline.default_callback">
<code class="descclassname">pypond.pipeline.</code><code class="descname">default_callback</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.pipeline.default_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Default no-op callback for group_by in the Pipeline constructor.</p>
</dd></dl>

</div>
<div class="section" id="module-pypond.range">
<span id="pypond-range-module"></span><h2>pypond.range module<a class="headerlink" href="#module-pypond.range" title="Permalink to this headline">¶</a></h2>
<p>Implementation of Pond TimeRange classes.</p>
<p><a class="reference external" href="http://software.es.net/pond/#/timerange">http://software.es.net/pond/#/timerange</a></p>
<dl class="class">
<dt id="pypond.range.TimeRange">
<em class="property">class </em><code class="descclassname">pypond.range.</code><code class="descname">TimeRange</code><span class="sig-paren">(</span><em>instance_or_begin</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.range.TimeRangeBase" title="pypond.range.TimeRangeBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.range.TimeRangeBase</span></code></a></p>
<p>Builds a new TimeRange. First arg may be of several different formats:</p>
<ul class="simple">
<li>Another TimeRange (copy constructor)</li>
<li>A python tuple, list or pyrsistent.PVector object containing two
python datetime objects or ms timestamps.</li>
<li>Two arguments, begin and end, each of which may be a datetime object,
or a ms timestamp.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>instance_or_begin</strong> (<em>TimeRange, iterable, int or datetime.datetime.</em>) &#8211; See above for variations.</li>
<li><strong>end</strong> (<em>int or datetime.datetime, optional</em>) &#8211; Optional arg for the end of the time range.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">TimeRangeException</span></code> &#8211; Raised to indicate errors with args.</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.range.TimeRange.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>string repr method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String repr method.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the begin time of the TimeRange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The begin time.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if other is completely inside this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Another time range object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns true if other range is completely inside this one.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.disjoint">
<code class="descname">disjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.disjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the passed in other Range in no way
overlaps this time Range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Another time range object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns true if other range in no way overlaps this one.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.duration">
<code class="descname">duration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return epoch milliseconds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Duration in ms.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the end time of the TimeRange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The end time.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the two TimeRanges can be considered equal,
in that they have the same times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Another time range object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if both object represent the same time range.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.extents">
<code class="descname">extents</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Timerange which covers the extents of this and
other combined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Another time range object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New time range which covers the extents of this and the
other range combined.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.humanize">
<code class="descname">humanize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.humanize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a human friendly version of the TimeRange, e.g.
&#8220;Aug 1, 2014 05:19:59 am to Aug 1, 2014 07:41:06 am&#8221;</p>
<p>This displays in local time, so don&#8217;t freak out.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Human friendly time range string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.humanize_duration">
<code class="descname">humanize_duration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.humanize_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Humanize the duration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Humanized duration string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new TimeRange which represents the intersection
(overlapping) part of this and other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Another time range object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A new time range object representing the intersection (overlapping)
part of this and the other.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.range.TimeRange.last_day">
<em class="property">static </em><code class="descname">last_day</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.last_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a time range spanning last 24 hours</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new time range object of the requested duration.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.range.TimeRange.last_month">
<em class="property">static </em><code class="descname">last_month</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.last_month" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a time range spanning last month.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new time range object of the requested duration.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.range.TimeRange.last_ninety_days">
<em class="property">static </em><code class="descname">last_ninety_days</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.last_ninety_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a time range spanning last 90 days</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new time range object of the requested duration.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.range.TimeRange.last_seven_days">
<em class="property">static </em><code class="descname">last_seven_days</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.last_seven_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a time range spanning last 7 days</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new time range object of the requested duration.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.range.TimeRange.last_thirty_days">
<em class="property">static </em><code class="descname">last_thirty_days</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.last_thirty_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a time range spanning last 30 days</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new time range object of the requested duration.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.overlaps">
<code class="descname">overlaps</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the passed in other TimeRange overlaps this time Range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Another time range object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns true if other range overlaps this one.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.range">
<code class="descname">range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.range" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the internal range, which is an Immutable List containing
begin and end values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Immutable list containing the range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyrsistent.pvector</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.relative_string">
<code class="descname">relative_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.relative_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a human friendly version of the TimeRange, e.g.
e.g. &#8220;a few seconds ago to a month ago&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Another human friendly duration string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.set_begin">
<code class="descname">set_begin</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.set_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a new begin time on the TimeRange. The result will be a new TimeRange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; New time range boundary.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A new time range object reflecting the new range bounds.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">TimeRangeException</span></code> &#8211; Raised on invalid arg.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.set_end">
<code class="descname">set_end</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.set_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a new end time on the TimeRange. The result will be a new TimeRange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; New time range boundary.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A new time range object reflecting the new range bounds.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">TimeRangeException</span></code> &#8211; Raised on invalid arg.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the TimeRange as a python list of two ms timestamps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">List of two timestamps.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.to_local_string">
<code class="descname">to_local_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.to_local_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the TimeRange as a string expressed in local time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Timerange as a string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the TimeRange as a string, useful for serialization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String representaion of the range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.to_utc_string">
<code class="descname">to_utc_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.to_utc_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the TimeRange as a string expressed in UTC time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Timerange as string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.range.TimeRange.within">
<code class="descname">within</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRange.within" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this TimeRange is completely within the supplied
other TimeRange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Another time range object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns true if this range is completely inside the other one.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypond.range.TimeRangeBase">
<em class="property">class </em><code class="descclassname">pypond.range.</code><code class="descname">TimeRangeBase</code><a class="headerlink" href="#pypond.range.TimeRangeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.bases.PypondBase" title="pypond.bases.PypondBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.bases.PypondBase</span></code></a></p>
<p>Base for TimeRange</p>
<dl class="staticmethod">
<dt id="pypond.range.TimeRangeBase.awareness_check">
<em class="property">static </em><code class="descname">awareness_check</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRangeBase.awareness_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input to make sure datetimes are aware. Presumes an iterable
contaning datetimes, but will fail over to process a single
datetime object via duck typing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>list, tuple or pvector but will failover to datetime.</em>) &#8211; An interable of datetime objects</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">TimeRangeException</span></code> &#8211; Raised if a non-aware datetime object is found.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.range.TimeRangeBase.sanitize_list_input">
<em class="property">static </em><code class="descname">sanitize_list_input</code><span class="sig-paren">(</span><em>list_type</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRangeBase.sanitize_list_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate input when a pvector, list or tuple is passed in
as a constructor arg.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list_type</strong> (<em>list, tuple of pvector</em>) &#8211; Iterable containing args (epoch ms or datetime) that was passed to
the constructor.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Immutable list-like object with two elements - the beginning and
ending datetime of the range.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">pyrsistent.pvector</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">TimeRangeException</span></code> &#8211; Raised if bad args have been passed in.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.range.TimeRangeBase.validate_range">
<em class="property">static </em><code class="descname">validate_range</code><span class="sig-paren">(</span><em>range_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.range.TimeRangeBase.validate_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that the end time is not chronologically before the begin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">TimeRangeException</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>range_obj</strong> (<em>pyrsistent.pvector</em>) &#8211; The internal begin/end immutable range object.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">TimeRangeException</span></code> &#8211; Raised if end arg is earlier in time than begin.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypond.series">
<span id="pypond-series-module"></span><h2>pypond.series module<a class="headerlink" href="#module-pypond.series" title="Permalink to this headline">¶</a></h2>
<p>Implements the Pond TimeSeries class.</p>
<p><a class="reference external" href="http://software.es.net/pond/#/timeseries">http://software.es.net/pond/#/timeseries</a></p>
<dl class="class">
<dt id="pypond.series.TimeSeries">
<em class="property">class </em><code class="descclassname">pypond.series.</code><code class="descname">TimeSeries</code><span class="sig-paren">(</span><em>instance_or_wire</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.bases.PypondBase" title="pypond.bases.PypondBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.bases.PypondBase</span></code></a></p>
<p>A TimeSeries is a a Series where each event is an association of a timestamp
and some associated data.</p>
<p>Data passed into it may have the following format, which is our wire format</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;traffic&quot;</span><span class="p">,</span>
<span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
<span class="s2">&quot;points&quot;</span><span class="p">:</span> <span class="p">[</span>
   <span class="p">[</span><span class="mi">1400425947000</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
   <span class="p">[</span><span class="mi">1400425948000</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
   <span class="p">[</span><span class="mi">1400425949000</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
   <span class="p">[</span><span class="mi">1400425950000</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
   <span class="o">...</span>
 <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, the TimeSeries may be constructed from a list of Event objects.</p>
<p>Internaly the above series is represented as two parts:</p>
<ul>
<li><dl class="first docutils">
<dt>Collection - an Immutable.List of Events and associated methods</dt>
<dd><p class="first last">to query and manipulate that list</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Meta data  - an Immutable.Map of extra data associated with the</dt>
<dd><p class="first last">TimeSeries</p>
</dd>
</dl>
</li>
</ul>
<p>The events stored in the collection may be Events (timestamp based),
TimeRangeEvents (time range based) or IndexedEvents (an alternative form
of a time range, such as &#8220;2014-08&#8221; or &#8220;1d-1234&#8221;)</p>
<p>The timerange associated with a TimeSeries is simply the bounds of the
events within it (i.e. the min and max times).</p>
<p>Initialize a TimeSeries object from:</p>
<ul class="simple">
<li>Another TimeSeries/copy ctor</li>
<li>An event list</li>
<li>From the wire format</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instance_or_wire</strong> (<em>TimeSeries, list of events, wire format</em>) &#8211; See above</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">TimeSeriesException</span></code> &#8211; Raised when args can not be properly handled.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pypond.series.TimeSeries.event_type_map">
<code class="descname">event_type_map</code><a class="headerlink" href="#pypond.series.TimeSeries.event_type_map" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict</em> &#8211; Map text keys from wire format to the appropriate Event class.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>call to_string()</p>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.aggregate">
<code class="descname">aggregate</code><span class="sig-paren">(</span><em>func</em>, <em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregates the events down using a user defined function to
do the reduction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> (<em>function</em>) &#8211; Function to pass to map reduce to aggregate.</li>
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dict of reduced values</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>field_spec=None</em>, <em>window='5m'</em>, <em>method='linear'</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align entry point</p>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.at">
<code class="descname">at</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Access the series events via numeric index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> (<em>int</em>) &#8211; An array index</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Event object found at index i</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.at_first">
<code class="descname">at_first</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.at_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first event in the series</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The first event in the series.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.at_last">
<code class="descname">at_last</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.at_last" title="Permalink to this definition">¶</a></dt>
<dd><p>Return last event in the series</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The last event in the series.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.at_time">
<code class="descname">at_time</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.at_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an event in the series by its time. This is the same
as calling <cite>bisect</cite> first and then using <cite>at</cite> with the index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> (<em>datetime.datetime</em>) &#8211; A datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The event at the designated time.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.event.Event" title="pypond.event.Event">Event</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.avg">
<code class="descname">avg</code><span class="sig-paren">(</span><em>field_spec=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Get avg</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Average value</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the earliest time represented in the TimeSeries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The begin time of the underlying time range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.begin_timestamp">
<code class="descname">begin_timestamp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.begin_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the earliest time represented in the TimeSeries
in epoch ms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The begin time of the underlying time range in epoch ms.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.bisect">
<code class="descname">bisect</code><span class="sig-paren">(</span><em>dtime</em>, <em>b=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the index that is just less than the time t supplied.
In other words every event at the returned index or less
has a time before the supplied t, and every sample after the
index has a time later than the supplied t.</p>
<p>Optionally supply a begin index to start searching from. Returns
index that is the greatest but still below t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; Date time object to search with</li>
<li><strong>b</strong> (<em>int, optional</em>) &#8211; An index position to start searching from.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The index of the Event searched for by dtime.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.series.TimeSeries.build_metadata">
<em class="property">static </em><code class="descname">build_metadata</code><span class="sig-paren">(</span><em>meta</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.build_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the metadata out of the incoming wire format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>meta</strong> (<em>dict</em>) &#8211; Incoming wire format.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Immutable dict of metadata</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">pyrsistent.pmap</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.clean">
<code class="descname">clean</code><span class="sig-paren">(</span><em>field_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new TimeSeries by testing the field_path
values for being valid (not NaN, null or undefined).
The resulting TimeSeries will be clean for that fieldSpec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New time series from clean values from the field spec.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.collapse">
<code class="descname">collapse</code><span class="sig-paren">(</span><em>field_spec_list</em>, <em>name</em>, <em>reducer</em>, <em>append=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a fieldSpecList (list of column names) and collapses
them to a new column which is the reduction of the matched columns
in the fieldSpecList.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec_list</strong> (<em>list</em>) &#8211; List of columns to collapse. If you need to retrieve deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].</li>
<li><strong>name</strong> (<em>str</em>) &#8211; Name of new column containing collapsed values.</li>
<li><strong>reducer</strong> (<em>Function to pass to reducer.</em>) &#8211; function</li>
<li><strong>append</strong> (<em>bool, optional</em>) &#8211; Append collapsed column to existing data or fresh data payload.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new time series from the collapsed columns.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.collect_by_fixed_window">
<code class="descname">collect_by_fixed_window</code><span class="sig-paren">(</span><em>window_size</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.collect_by_fixed_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Summary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>window_size</strong> (<em>str</em>) &#8211; The window size - 1d, 6h, etc</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns the _results attribute from a Pipeline object after processing.
Will contain Collection objects.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list or dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.collection">
<code class="descname">collection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the internal collection of events for this TimeSeries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Internal collection.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection">Collection</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.columns">
<code class="descname">columns</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>create a list of the underlying columns.</p>
<p>Due to the nature of the event data and using dicts, the order
of the column list might be somewhat unpredictable. When generating
points, this is solved by passing the column list to .to_point()
as an optional argument to ensure that the points and the columns
are properly aligned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">List of column names.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.count">
<code class="descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.count" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Number of rows in series.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>timerange</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop the TimeSeries to the specified TimeRange and return
a new TimeSeries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timerange</strong> (<a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange"><em>TimeRange</em></a>) &#8211; Bounds of the new TimeSeries</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The new cropped TimeSeries instance.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.daily_rollup">
<code class="descname">daily_rollup</code><span class="sig-paren">(</span><em>aggregation</em>, <em>to_events=False</em>, <em>utc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.daily_rollup" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a new TimeSeries by dividing events into days. The days are
in either local or UTC time, depending on if utc(true) is set on the
Pipeline.</p>
<p>Each window then has an aggregation specification applied as
<cite>aggregation</cite>. This specification describes a mapping of output
columns to fieldNames to aggregation functions. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;in_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;out_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;in_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
    <span class="s1">&#39;out_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will aggregate both the &#8220;in&#8221; and &#8220;out&#8221; columns, using the avg
aggregation function will perform avg and max aggregations on the
in and out columns, across all events within each day, and the
results will be put into the 4 new columns in_avg, out_avg, in_max
and out_max.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">hourly_max_temp</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">daily_rollup</span><span class="p">(</span>
    <span class="p">{</span><span class="s1">&#39;max_temp&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()}}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This helper function defaults to rendering the aggregations in localtime.
The reason for this is that rendering in localtime makes the most sense
on the client side - like rendering a timeseries chart. A user looking
at a chart in UTC might not make much sense.</p>
<p>Since this is now being used in servers side applications, the optional
arg utc can be set to True to force it to render in UTC instead.</p>
<p>Probably best to favor using .fixed_window_rollup() when wanting to
render in UTC.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>aggregation</strong> (<em>dict</em>) &#8211; The aggregation specification e.g. {&#8216;max_temp&#8217;: {&#8216;temperature&#8217;: Functions.max()}}</li>
<li><strong>to_event</strong> (<em>bool, optional</em>) &#8211; Do conversion to Event objects</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting rolled up TimeSeries.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the latest time represented in the TimeSeries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The end time of the underlying time range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.end_timestamp">
<code class="descname">end_timestamp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.end_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the latest time represented in the TimeSeries
in epoch ms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The end time of the underlying time range in epoch ms.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.series.TimeSeries.equal">
<em class="property">static </em><code class="descname">equal</code><span class="sig-paren">(</span><em>series1</em>, <em>series2</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check equality - same instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>series1</strong> (<a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries"><em>TimeSeries</em></a>) &#8211; A time series</li>
<li><strong>series2</strong> (<a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries"><em>TimeSeries</em></a>) &#8211; Another time series</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Are the two the same instance?</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">event_type_map</code><em class="property"> = {'index': &lt;class 'pypond.indexed_event.IndexedEvent'&gt;, 'timerange': &lt;class 'pypond.timerange_event.TimeRangeEvent'&gt;, 'time': &lt;class 'pypond.event.Event'&gt;}</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.events">
<code class="descname">events</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.events" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator to allow for..of loops over series.events()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Generator for loops.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iterator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.fill">
<code class="descname">fill</code><span class="sig-paren">(</span><em>field_spec=None</em>, <em>method='zero'</em>, <em>fill_limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the data in this timeseries and &#8220;fill&#8221; any missing
or invalid values. This could be setting None values to zero
so mathematical operations will succeed, interpolate a new
value, or pad with the previously given value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_spec</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.</p>
<p>If None, the default column field &#8216;value&#8217; will be used.</p>
</li>
<li><strong>method</strong> (<em>str, optional</em>) &#8211; Filling method: zero | linear | pad</li>
<li><strong>fill_limit</strong> (<em>None, optional</em>) &#8211; Set a limit on the number of consecutive events will be filled
before it starts returning invalid values. For linear fill,
no filling will happen if the limit is reached before a valid
value is found.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A clone of this TimeSeries with a new Collection generated by
the fill operation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.fixed_window_rollup">
<code class="descname">fixed_window_rollup</code><span class="sig-paren">(</span><em>window_size</em>, <em>aggregation</em>, <em>to_events=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.fixed_window_rollup" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a new TimeSeries by dividing events within the TimeSeries
across multiple fixed windows of size <cite>windowSize</cite>.</p>
<p>Note that these are windows defined relative to Jan 1st, 1970,
and are UTC, so this is best suited to smaller window sizes
(hourly, 5m, 30s, 1s etc), or in situations where you don&#8217;t care
about the specific window, just that the data is smaller.</p>
<p>Each window then has an aggregation specification applied as
<cite>aggregation</cite>. This specification describes a mapping of output
columns to fieldNames to aggregation functions. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;in_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;out_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;in_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
    <span class="s1">&#39;out_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will aggregate both the &#8220;in&#8221; and &#8220;out&#8221; columns, using the avg
aggregation function will perform avg and max aggregations on the
in and out columns, across all events within each hour, and the
results will be put into the 4 new columns in_avg, out_avg, in_max
and out_max.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">daily_avg</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">fixed_window_rollup</span><span class="p">(</span><span class="s1">&#39;1d&#39;</span><span class="p">,</span>
    <span class="p">{</span><span class="s1">&#39;value_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()}}</span>
<span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>window_size</strong> (<em>str</em>) &#8211; The size of the window, e.g. &#8216;6h&#8217; or &#8216;5m&#8217;</li>
<li><strong>aggregation</strong> (<a class="reference internal" href="#pypond.util.Options" title="pypond.util.Options"><em>Options</em></a>) &#8211; The aggregation specification</li>
<li><strong>to_events</strong> (<em>bool, optional</em>) &#8211; Convert to events</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting rolled up TimeSeries</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.hourly_rollup">
<code class="descname">hourly_rollup</code><span class="sig-paren">(</span><em>aggregation</em>, <em>to_events=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.hourly_rollup" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a new TimeSeries by dividing events into hours. The hours are
in either local or UTC time, depending on if utc(true) is set on the
Pipeline.</p>
<p>Each window then has an aggregation specification applied as
<cite>aggregation</cite>. This specification describes a mapping of output
columns to fieldNames to aggregation functions. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;in_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;out_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;in_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
    <span class="s1">&#39;out_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will aggregate both the &#8220;in&#8221; and &#8220;out&#8221; columns, using the avg
aggregation function will perform avg and max aggregations on the
in and out columns, across all events within each hour, and the
results will be put into the 4 new columns in_avg, out_avg, in_max
and out_max.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">hourly_max_temp</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">hourly_rollup</span><span class="p">(</span>
    <span class="p">{</span><span class="s1">&#39;max_temp&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()}}</span>
<span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>aggregation</strong> (<em>dict</em>) &#8211; The aggregation specification e.g. {&#8216;max_temp&#8217;: {&#8216;temperature&#8217;: Functions.max()}}</li>
<li><strong>to_event</strong> (<em>bool, optional</em>) &#8211; Do conversion to Event objects</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting rolled up TimeSeries.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.index">
<code class="descname">index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Get the index.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.index.Index" title="pypond.index.Index">Index</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.index_as_range">
<code class="descname">index_as_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.index_as_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Index returned as time range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Index as a TimeRange or None</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.index_as_string">
<code class="descname">index_as_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.index_as_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Index represented as a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String format of Index or None.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.is_utc">
<code class="descname">is_utc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.is_utc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data utc.</p>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.map" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Takes an operator that is used to remap events from this TimeSeries to</dt>
<dd>new set of Events. The result is returned via the callback.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>op</strong> (<em>function</em>) &#8211; An operator which will be passed each event and which should
return a new event.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A clone of this TimeSeries with a new Collection generated by
the map operation.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Get max</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Max value</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Get mean</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Mean value</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.median">
<code class="descname">median</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Get median</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Median value</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.meta">
<code class="descname">meta</code><span class="sig-paren">(</span><em>key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the meta data about this TimeSeries as a JSON object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>str, optional</em>) &#8211; Optional metadata key to fetch value for</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Return a thawed metadata dict or the value specified by <em>key</em>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict or key/value</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Get min</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Min value</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.monthly_rollup">
<code class="descname">monthly_rollup</code><span class="sig-paren">(</span><em>aggregation</em>, <em>to_events=False</em>, <em>utc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.monthly_rollup" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a new TimeSeries by dividing events into months. The months are
in either local or UTC time, depending on if utc(true) is set on the
Pipeline.</p>
<p>Each window then has an aggregation specification applied as
<cite>aggregation</cite>. This specification describes a mapping of output
columns to fieldNames to aggregation functions. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;in_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;out_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;in_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
    <span class="s1">&#39;out_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will aggregate both the &#8220;in&#8221; and &#8220;out&#8221; columns, using the avg
aggregation function will perform avg and max aggregations on the
in and out columns, across all events within each month, and the
results will be put into the 4 new columns in_avg, out_avg, in_max
and out_max.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">hourly_max_temp</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">monthly_rollup</span><span class="p">(</span>
    <span class="p">{</span><span class="s1">&#39;max_temp&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()}}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This helper function defaults to rendering the aggregations in localtime.
The reason for this is that rendering in localtime makes the most sense
on the client side - like rendering a timeseries chart. A user looking
at a chart in UTC might not make much sense.</p>
<p>Since this is now being used in servers side applications, the optional
arg utc can be set to True to force it to render in UTC instead.</p>
<p>Probably best to favor using .fixed_window_rollup() when wanting to
render in UTC.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>aggregation</strong> (<em>dict</em>) &#8211; The aggregation specification e.g. {&#8216;max_temp&#8217;: {&#8216;temperature&#8217;: Functions.max()}}</li>
<li><strong>to_event</strong> (<em>bool, optional</em>) &#8211; Do conversion to Event objects</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting rolled up TimeSeries.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Data name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.percentile">
<code class="descname">percentile</code><span class="sig-paren">(</span><em>perc</em>, <em>field_path</em>, <em>method='linear'</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets percentile perc within the Collection. Numpy under
the hood.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>perc</strong> (<em>int</em>) &#8211; The percentile (should be between 0 and 100)</li>
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>method</strong> (<em>str, optional</em>) &#8211; <p>Specifies the interpolation method to use when the desired
percentile lies between two data points. Options are:</p>
<p>linear: i + (j - i) * fraction, where fraction is the fractional
part of the index surrounded by i and j.</p>
<p>lower: i</p>
<p>higher: j</p>
<p>nearest: i or j whichever is nearest</p>
<p>midpoint: (i + j) / 2</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The percentile.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.pipeline">
<code class="descname">pipeline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Pipeline with input source being initialized to
this TimeSeries collection. This allows pipeline operations
to be chained directly onto the TimeSeries to produce a new
TimeSeries or Event result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">New pipline.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.pipeline.Pipeline" title="pypond.pipeline.Pipeline">Pipeline</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>num</em>, <em>field_path=None</em>, <em>method='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets num quantiles within the Collection</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num</strong> (<em>Number of quantiles to divide the Collection into.</em>) &#8211; Description</li>
<li><strong>field_path</strong> (<em>None, optional</em>) &#8211; The field to return as the quantile. If not set, defaults
to &#8216;value.&#8217;</li>
<li><strong>method</strong> (<em>str, optional</em>) &#8211; <p>Specifies the interpolation method to use when the desired
percentile lies between two data points. Options are:</p>
<p>linear: i + (j - i) * fraction, where fraction is the fractional
part of the index surrounded by i and j.</p>
<p>lower: i</p>
<p>higher: j</p>
<p>nearest: i or j whichever is nearest</p>
<p>midpoint: (i + j) / 2</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An array of quantiles</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.range">
<code class="descname">range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.range" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for timerange()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">TimeRange internal of the underly collection.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.rate">
<code class="descname">rate</code><span class="sig-paren">(</span><em>field_spec=None</em>, <em>allow_negative=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.rate" title="Permalink to this definition">¶</a></dt>
<dd><p>derive entry point</p>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.rename_columns">
<code class="descname">rename_columns</code><span class="sig-paren">(</span><em>rename_map</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.rename_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries.map() helper function to rename columns in the underlying
events.</p>
<p>Takes a dict of columns to rename:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">new_ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">rename_columns</span><span class="p">({</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="s1">&#39;new_in&#39;</span><span class="p">,</span> <span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="s1">&#39;new_out&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>Returns a new time series containing new events. Columns not
in the dict will be retained and not renamed.</p>
<p>NOTE: as the name implies, this will only rename the main
&#8220;top level&#8221; (ie: non-deep) columns. If you need more
extravagant renaming, roll your own using map().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rename_map</strong> (<em>dict</em>) &#8211; Dict of columns to rename.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A clone of this TimeSeries with a new Collection generated by
the map operation.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.series.TimeSeries.same">
<em class="property">static </em><code class="descname">same</code><span class="sig-paren">(</span><em>series1</em>, <em>series2</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements JS Object.is() - same values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>series1</strong> (<a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries"><em>TimeSeries</em></a>) &#8211; A time series</li>
<li><strong>series2</strong> (<a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries"><em>TimeSeries</em></a>) &#8211; Another time series</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Do the two have the same values?</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>field_spec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.select" title="Permalink to this definition">¶</a></dt>
<dd><p>call select on the pipeline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_spec</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.</p>
<p>If None, the default &#8216;value&#8217; column will be used.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A clone of this TimeSeries with a new Collection generated by
the select operation.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.set_collection">
<code class="descname">set_collection</code><span class="sig-paren">(</span><em>coll</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.set_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a new underlying collection for this TimeSeries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coll</strong> (<a class="reference internal" href="#pypond.collection.Collection" title="pypond.collection.Collection"><em>Collection</em></a>) &#8211; New collection to assign to this TimeSeries</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New TimeSeries with Collection coll</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.set_meta">
<code class="descname">set_meta</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.set_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the metadata of the TimeSeries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>str</em>) &#8211; The metadata key</li>
<li><strong>value</strong> (<em>obj</em>) &#8211; The value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new TimeSeries with new metadata.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.set_name">
<code class="descname">set_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set name and generate a new TimeSeries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<em>str</em>) &#8211; New name</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Return a TimeSeries with a new name.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.size">
<code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of rows in series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Number in the series.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.size_valid">
<code class="descname">size_valid</code><span class="sig-paren">(</span><em>field_path</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.size_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of valid items in this collection.</p>
<p>Uses the fieldSpec to look up values in all events.
It then counts the number that are considered valid,
i.e. are not NaN, undefined or null.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Number of valid &lt;field_path&gt; values in the events.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a slice of events within the TimeSeries, returns a new
TimeSeries representing a portion of this TimeSeries from begin up to
but not including end. Uses typical python [slice:syntax].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>begin</strong> (<em>int</em>) &#8211; Slice begin index</li>
<li><strong>end</strong> (<em>int</em>) &#8211; Slice end index</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New instance with sliced collection.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.stdev">
<code class="descname">stdev</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Get std dev</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Standard deviation</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>field_path=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get sum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field_path</strong> (<em>str, list, tuple, None, optional</em>) &#8211; <p>Name of a single value to look up. If None, defaults to [&#8216;value&#8217;].
&#8220;Deep&#8221; syntax either [&#8216;deep&#8217;, &#8216;value&#8217;], (&#8216;deep&#8217;, &#8216;value&#8217;,)
or &#8216;deep.value.&#8217;</p>
<p>If field_path is None, then [&#8216;value&#8217;] will be the default.</p>
</li>
<li><strong>filter_func</strong> (<em>function, None</em>) &#8211; A function (static method really) from the Filters class in module
<cite>pypond.functions.Filters</cite>. It will control how bad or missing
(None, NaN, empty string) values will be cleansed or filtered
during aggregation. If no filter is specified, then the missing
values will be retained which will potentially cause errors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Summed values</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.timerange">
<code class="descname">timerange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.timerange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the extents of the TimeSeries as a TimeRange..</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">TimeRange internal of the underly collection.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.series.TimeSeries.timeseries_list_merge">
<em class="property">static </em><code class="descname">timeseries_list_merge</code><span class="sig-paren">(</span><em>data</em>, <em>series_list</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.timeseries_list_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge a list of time series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>dict or pvector</em>) &#8211; Data payload</li>
<li><strong>series_list</strong> (<em>list</em>) &#8211; List of TimeSeries instances.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New TimeSeries from merge.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.series.TimeSeries.timeseries_list_reduce">
<em class="property">static </em><code class="descname">timeseries_list_reduce</code><span class="sig-paren">(</span><em>data</em>, <em>series_list</em>, <em>reducer</em>, <em>field_spec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.timeseries_list_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces a list of TimeSeries objects using a reducer function. This works
by taking each event in each TimeSeries and collecting them together
based on timestamp. All events for a given time are then merged together
using the reducer function to produce a new Event. Those Events are then
collected together to form a new TimeSeries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>dict or pmap</em>) &#8211; Data payload</li>
<li><strong>series_list</strong> (<em>list</em>) &#8211; List of TimeSeries objects.</li>
<li><strong>reducer</strong> (<em>function</em>) &#8211; reducer function</li>
<li><strong>field_spec</strong> (<em>list, str, None, optional</em>) &#8211; <p>Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.</p>
<p>Can be set to None if the reducer does not require a field spec.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New time series containing the mapped events.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pypond.series.TimeSeries.timeseries_list_sum">
<em class="property">static </em><code class="descname">timeseries_list_sum</code><span class="sig-paren">(</span><em>data</em>, <em>series_list</em>, <em>field_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.timeseries_list_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of TimeSeries and sums them together to form a new
Timeseries.</p>
<p>const ts1 = new TimeSeries(weather1)
const ts2 = new TimeSeries(weather2)
const sum = TimeSeries.timeseries_list_sum({name: &#8220;sum&#8221;}, [ts1, ts2], [&#8220;temp&#8221;])</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>dict</em>) &#8211; Data payload</li>
<li><strong>series_list</strong> (<em>list</em>) &#8211; List of TimeSeries objects</li>
<li><strong>field_spec</strong> (<em>list, str, None, optional</em>) &#8211; Column or columns to look up. If you need to retrieve multiple deep
nested values that [&#8216;can.be&#8217;, &#8216;done.with&#8217;, &#8216;this.notation&#8217;].
A single deep value with a string.like.this.  If None, all columns
will be operated on.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New time series with summed values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the TimeSeries as a python dict.</p>
<p>This is actually like json.loads(s) - produces the
actual vanilla data structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Dictionary of columns and points</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Retruns the TimeSeries as a string, useful for serialization.</p>
<p>In JS land, this is synonymous with __str__ or __unicode__</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String version of to_json() for transmission/etc.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.series.TimeSeries.yearly_rollup">
<code class="descname">yearly_rollup</code><span class="sig-paren">(</span><em>aggregation</em>, <em>to_events=False</em>, <em>utc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.series.TimeSeries.yearly_rollup" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a new TimeSeries by dividing events into years. The years are
in either local or UTC time, depending on if utc(true) is set on the
Pipeline.</p>
<p>Each window then has an aggregation specification applied as
<cite>aggregation</cite>. This specification describes a mapping of output
columns to fieldNames to aggregation functions. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;in_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;out_avg&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">avg</span><span class="p">()},</span>
    <span class="s1">&#39;in_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
    <span class="s1">&#39;out_max&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will aggregate both the &#8220;in&#8221; and &#8220;out&#8221; columns, using the avg
aggregation function will perform avg and max aggregations on the
in and out columns, across all events within each year, and the
results will be put into the 4 new columns in_avg, out_avg, in_max
and out_max.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">hourly_max_temp</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">monthly_rollup</span><span class="p">(</span>
    <span class="p">{</span><span class="s1">&#39;max_temp&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="n">Functions</span><span class="o">.</span><span class="n">max</span><span class="p">()}}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This helper function defaults to rendering the aggregations in localtime.
The reason for this is that rendering in localtime makes the most sense
on the client side - like rendering a timeseries chart. A user looking
at a chart in UTC might not make much sense.</p>
<p>Since this is now being used in servers side applications, the optional
arg utc can be set to True to force it to render in UTC instead.</p>
<p>Probably best to favor using .fixed_window_rollup() when wanting to
render in UTC.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>aggregation</strong> (<em>dict</em>) &#8211; The aggregation specification e.g. {&#8216;max_temp&#8217;: {&#8216;temperature&#8217;: Functions.max()}}</li>
<li><strong>to_event</strong> (<em>bool, optional</em>) &#8211; Do conversion to Event objects</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting rolled up TimeSeries.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.series.TimeSeries" title="pypond.series.TimeSeries">TimeSeries</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypond.timerange_event">
<span id="pypond-timerange-event-module"></span><h2>pypond.timerange_event module<a class="headerlink" href="#module-pypond.timerange_event" title="Permalink to this headline">¶</a></h2>
<p>TimeRangeEvent associates data with a specific time range rather than
at a discret time like Event does.</p>
<dl class="class">
<dt id="pypond.timerange_event.TimeRangeEvent">
<em class="property">class </em><code class="descclassname">pypond.timerange_event.</code><code class="descname">TimeRangeEvent</code><span class="sig-paren">(</span><em>instance_or_args</em>, <em>arg2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.event.EventBase" title="pypond.event.EventBase"><code class="xref py py-class docutils literal"><span class="pre">pypond.event.EventBase</span></code></a></p>
<p>The creation of an TimeRangeEvent is done by combining two parts -
the timerange and the data.</p>
<p>To construct you specify a TimeRange, along with the data.</p>
<p>The first arg can be:</p>
<ul class="simple">
<li>a TimeRangeEvent instance (copy ctor)</li>
<li>a pyrsistent.PMap, or</li>
<li>a python tuple, list or pyrsistent.PVector object containing two
python datetime objects or ms timestamps - the args for the
TimeRange object.</li>
</ul>
<p>To specify the data you can supply either:</p>
<ul class="simple">
<li>a python dict</li>
<li>a pyrsistent.PMap, or</li>
<li>a simple type such as an integer. In the case of the simple type
this is a shorthand for supplying {&#8220;value&#8221;: v}.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>instance_or_args</strong> (<em>TimeRange, iterable, pyrsistent.pmap</em>) &#8211; See above</li>
<li><strong>arg2</strong> (<em>dict, pmap, int, float, str, optional</em>) &#8211; See above.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>The begin time of this Event, which will be just the timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Beginning of range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.end" title="Permalink to this definition">¶</a></dt>
<dd><p>The end time of this Event, which will be just the timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">End of range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.humanize_duration">
<code class="descname">humanize_duration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.humanize_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Humanize the timerange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Humanized string of the time range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.key">
<code class="descname">key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a range string in the format &#8216;begin,end&#8217; as expressed
as ms since the epoch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The begin and end of the timerange in ms since the epoch.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data portion of the event and returns a new TimeRangeEvent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>dict</em>) &#8211; The new data portion for this event object.</li>
<li><strong>data</strong> &#8211; New payload to set as the data for this event.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">TimeRangeEvent - a new TimeRangeEvent object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new time range event object with new data payload.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pypond.timerange_event.TimeRangeEvent" title="pypond.timerange_event.TimeRangeEvent">TimeRangeEvent</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.timerange">
<code class="descname">timerange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.timerange" title="Permalink to this definition">¶</a></dt>
<dd><p>The TimeRange of this data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The underlying time range object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pypond.range.TimeRange" title="pypond.range.TimeRange">TimeRange</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.timerange_as_local_string">
<code class="descname">timerange_as_local_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.timerange_as_local_string" title="Permalink to this definition">¶</a></dt>
<dd><p>The timerange of this data, in Local time, as a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Formatted time string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.timerange_as_utc_string">
<code class="descname">timerange_as_utc_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.timerange_as_utc_string" title="Permalink to this definition">¶</a></dt>
<dd><p>The timerange of this data, in UTC time, as a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Formatted time string</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.timestamp">
<code class="descname">timestamp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>The timestamp of this Event data. It&#8217;s just the beginning
of the range in this case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Beginning of range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.to_json" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Returns the TimeRangeEvent as a JSON object, essentially</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">timerange</span><span class="p">:</span> <span class="n">tr</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="o">...</span><span class="p">}}</span>
</pre></div>
</div>
<p>This is actually like json.loads(s) - produces the
actual data structure from the object internal data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Dict representation of internals (timerange, data).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.to_point">
<code class="descname">to_point</code><span class="sig-paren">(</span><em>cols=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a flat array starting with the timestamp, followed by the values.</p>
<p>Can be given an optional list of columns so the returned list will
have the values in order. Primarily for the TimeSeries wire format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cols</strong> (<em>list, optional</em>) &#8211; List of data columns to order the data points in so the
TimeSeries wire format lines up correctly. If not specified,
the points will be whatever order that dict.values() decides
to return it in.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Epoch ms followed by points.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pypond.timerange_event.TimeRangeEvent.type">
<code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.timerange_event.TimeRangeEvent.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the type of this event type</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The class of this event type.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">class</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypond.util">
<span id="pypond-util-module"></span><h2>pypond.util module<a class="headerlink" href="#module-pypond.util" title="Permalink to this headline">¶</a></h2>
<p>Various utilities for the pypond code.  Primarily functions to take
care of consistent handling and conversion of time values as we are
trying to traffic in aware datetime objects in UTC time.</p>
<p>Additionally some boolean test functions and assorted other utility functions.</p>
<dl class="class">
<dt id="pypond.util.Capsule">
<em class="property">class </em><code class="descclassname">pypond.util.</code><code class="descname">Capsule</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.Capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypond.util.Options" title="pypond.util.Options"><code class="xref py py-class docutils literal"><span class="pre">pypond.util.Options</span></code></a></p>
<p>Straight subclass of Options so there is no confusion between this
and the pipeline Options. Employing this to mimic the Javascript
Object in cases where using a Python dict would cause confusion
porting the code.</p>
</dd></dl>

<dl class="class">
<dt id="pypond.util.ObjectEncoder">
<em class="property">class </em><code class="descclassname">pypond.util.</code><code class="descname">ObjectEncoder</code><span class="sig-paren">(</span><em>skipkeys=False</em>, <em>ensure_ascii=True</em>, <em>check_circular=True</em>, <em>allow_nan=True</em>, <em>sort_keys=False</em>, <em>indent=None</em>, <em>separators=None</em>, <em>encoding='utf-8'</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.ObjectEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">json.encoder.JSONEncoder</span></code></p>
<p>Class to allow arbitrary python objects to be json encoded with
json.dumps()/etc by defining a .to_json() method on your object.</p>
<p>We need this for encoding lists of custom Event (etc) objects.</p>
<p>Usage: json.dumps(your_cool_object, cls=ObjectEncoder)</p>
<dl class="method">
<dt id="pypond.util.ObjectEncoder.default">
<code class="descname">default</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.ObjectEncoder.default" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypond.util.Options">
<em class="property">class </em><code class="descclassname">pypond.util.</code><code class="descname">Options</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.Options" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Encapsulation object for Pipeline options.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">o</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>

<span class="ow">and</span>

<span class="n">o</span> <span class="o">=</span> <span class="n">Options</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>

<span class="n">Are</span> <span class="n">identical</span><span class="o">.</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>initial</strong> (<em>dict, optional</em>) &#8211; Can supply keyword args for initial values.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pypond.util.Options.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.Options.to_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pypond.util.aware_dt_from_args">
<code class="descclassname">pypond.util.</code><code class="descname">aware_dt_from_args</code><span class="sig-paren">(</span><em>dtargs</em>, <em>localize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.aware_dt_from_args" title="Permalink to this definition">¶</a></dt>
<dd><p>generate an aware datetime object using datetime.datetime kwargs.</p>
<p>can generate a localized version as well, but please don&#8217;t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dtargs</strong> (<em>dict</em>) &#8211; Dict containing the args you pass to datetime.datetime.</li>
<li><strong>localize</strong> (<em>bool, optional</em>) &#8211; Will create a new object in localtime, but just don&#8217;t do it.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New datetime object</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">datetime.datetime</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">UtilityException</span></code> &#8211; Raised if the args are wrong type.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.aware_utcnow">
<code class="descclassname">pypond.util.</code><code class="descname">aware_utcnow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.aware_utcnow" title="Permalink to this definition">¶</a></dt>
<dd><p>return an aware utcnow() datetime rounded to milliseconds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">New datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.dt_from_ms">
<code class="descclassname">pypond.util.</code><code class="descname">dt_from_ms</code><span class="sig-paren">(</span><em>msec</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.dt_from_ms" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a datetime object from epoch milliseconds</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msec</strong> (<em>int</em>) &#8211; epoch milliseconds</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New datetime object from ms</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.dt_is_aware">
<code class="descclassname">pypond.util.</code><code class="descname">dt_is_aware</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.dt_is_aware" title="Permalink to this definition">¶</a></dt>
<dd><p>see if a datetime object is aware</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; A datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns True if the dtime is aware/non-naive.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.format_dt">
<code class="descclassname">pypond.util.</code><code class="descname">format_dt</code><span class="sig-paren">(</span><em>dtime</em>, <em>localize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.format_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Format for human readable output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; A datetime object</li>
<li><strong>localize</strong> (<em>bool, optional</em>) &#8211; Display as local time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Formatted date string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.generate_paths">
<code class="descclassname">pypond.util.</code><code class="descname">generate_paths</code><span class="sig-paren">(</span><em>dic</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.generate_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of all possible field paths in a dict. This is
for determining all paths in a dict when none is given.</p>
<p>Currently unused, but keeping since we will probably need it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dic</strong> (<em>dict</em>) &#8211; A dict, generally the payload from an Event class.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of strings of all the paths in the dict.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.humanize_dt">
<code class="descclassname">pypond.util.</code><code class="descname">humanize_dt</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.humanize_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>format time format display for humanize maneuvers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; A datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Datetime formatted as a string.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.humanize_dt_ago">
<code class="descclassname">pypond.util.</code><code class="descname">humanize_dt_ago</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.humanize_dt_ago" title="Permalink to this definition">¶</a></dt>
<dd><p>format to &#8220;23 minutes ago&#8221; style format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; A datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Humanized string.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.humanize_duration">
<code class="descclassname">pypond.util.</code><code class="descname">humanize_duration</code><span class="sig-paren">(</span><em>delta</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.humanize_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>format for a single duration value - takes datatime.timedelta as arg</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>delta</strong> (<em>datetime.timedelta</em>) &#8211; A time delta</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Humanize delta to duration.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.is_function">
<code class="descclassname">pypond.util.</code><code class="descname">is_function</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.is_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a value is a function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>func</strong> (<em>obj</em>) &#8211; A value</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Is the object a python function?</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.is_nan">
<code class="descclassname">pypond.util.</code><code class="descname">is_nan</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.is_nan" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a value is NaN</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>obj</em>) &#8211; A value</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Is it NaN?</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.is_pipeline">
<code class="descclassname">pypond.util.</code><code class="descname">is_pipeline</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.is_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if something is a Pipeline object. This is put here
with a deferred import statement to avoid circular imports
so the I/O don&#8217;t need to import pipeline.py.</p>
<p>This probably does not need to be deferred but doing it
for safety sake.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj</strong> (<em>object</em>) &#8211; An object to test to see if it&#8217;s a Pipeline.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if Pipeline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.is_pmap">
<code class="descclassname">pypond.util.</code><code class="descname">is_pmap</code><span class="sig-paren">(</span><em>pmap</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.is_pmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Check this here so people don&#8217;t mistake pmap and PMap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pmap</strong> (<em>obj</em>) &#8211; An object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns True if it is a pyrsistent.pmap</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.is_pvector">
<code class="descclassname">pypond.util.</code><code class="descname">is_pvector</code><span class="sig-paren">(</span><em>pvector</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.is_pvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Check this here so people don&#8217;t mistake PVector and pvector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pvector</strong> (<em>obj</em>) &#8211; An object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns True if it is a pyrsistent.pvector</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.is_valid">
<code class="descclassname">pypond.util.</code><code class="descname">is_valid</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a value is valid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>obj</em>) &#8211; A value</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Is it valid?</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.localtime_from_ms">
<code class="descclassname">pypond.util.</code><code class="descname">localtime_from_ms</code><span class="sig-paren">(</span><em>msec</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.localtime_from_ms" title="Permalink to this definition">¶</a></dt>
<dd><p>generate an aware localtime datetime object from ms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msec</strong> (<em>int</em>) &#8211; epoch milliseconds</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New datetime object</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.localtime_info_from_utc">
<code class="descclassname">pypond.util.</code><code class="descname">localtime_info_from_utc</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.localtime_info_from_utc" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract local TZ formatted values from an aware UTC datetime object.
This is used by the index string methods when grouping data for
local display.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; An aware UTC datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict with formatted elements (zero-padded months, etc) extracted
from the local version.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.monthdelta">
<code class="descclassname">pypond.util.</code><code class="descname">monthdelta</code><span class="sig-paren">(</span><em>date</em>, <em>delta</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.monthdelta" title="Permalink to this definition">¶</a></dt>
<dd><p>because we wish datetime.timedelta had a month kwarg.</p>
<p>Courtesy of: <a class="reference external" href="http://stackoverflow.com/a/3425124/3916180">http://stackoverflow.com/a/3425124/3916180</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>date</strong> (<em>datetime.date</em>) &#8211; Date object</li>
<li><strong>delta</strong> (<em>int</em>) &#8211; Month delta</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New Date object with delta offset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">datetime.date</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.ms_from_dt">
<code class="descclassname">pypond.util.</code><code class="descname">ms_from_dt</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.ms_from_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a datetime object into ms since epoch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; A datetime object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">epoch milliseconds</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.nested_get">
<code class="descclassname">pypond.util.</code><code class="descname">nested_get</code><span class="sig-paren">(</span><em>dic</em>, <em>keys</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.nested_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Address a nested dict with a list of keys to fetch a value.
This is functionaly similar to the standard functools.reduce()
method employing dict.get, but this returns &#8216;bad_path&#8217; if the path
does not exist. This is because we need to differentiate between
an existing value that is actually None vs. the dict.get()
failover. Would have preferred to return False, but who knows
if we&#8217;ll end up with data containing Boolean values.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sample_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">nested_set</span><span class="p">(</span><span class="n">sample_dict</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">],</span> <span class="mi">23</span><span class="p">)</span>
<span class="n">nested_get</span><span class="p">(</span><span class="n">sample_dict</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;quux&#39;</span><span class="p">])</span>
<span class="kc">False</span>
</pre></div>
</div>
<p>Unlike nested_set(), this will not create a new path branch if
it does not already exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dic</strong> (<em>dict</em>) &#8211; The dict we are working with</li>
<li><strong>keys</strong> (<em>list</em>) &#8211; A lsit of nested keys</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Whatever value was at the terminus of the keys.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">obj</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.nested_set">
<code class="descclassname">pypond.util.</code><code class="descname">nested_set</code><span class="sig-paren">(</span><em>dic</em>, <em>keys</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.nested_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Address a nested dict with a list of keys and set a value.
If part of the path does not exist, it will be created.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sample_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">nested_set</span><span class="p">(</span><span class="n">sample_dict</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">],</span> <span class="mi">23</span><span class="p">)</span>
<span class="p">{</span><span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="mi">23</span><span class="p">}}</span>
<span class="n">nested_set</span><span class="p">(</span><span class="n">sample_dict</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">],</span> <span class="mi">25</span><span class="p">)</span>
<span class="p">{</span><span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">}}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dic</strong> (<em>dict</em>) &#8211; The dict we are workign with.</li>
<li><strong>keys</strong> (<em>list</em>) &#8211; A list of nested keys</li>
<li><strong>value</strong> (<em>obj</em>) &#8211; Whatever we want to set the ultimate key to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.sanitize_dt">
<code class="descclassname">pypond.util.</code><code class="descname">sanitize_dt</code><span class="sig-paren">(</span><em>dtime</em>, <em>testing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.sanitize_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure the datetime object is in UTC/etc. Also round incoming
datetime objects to milliseconds.</p>
<p>Allow disabling warnings when testing. Warning primarily exists
to herd users into not passing in non-UTC tz datetime objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; A datetime object</li>
<li><strong>testing</strong> (<em>bool, optional</em>) &#8211; Suppress warnings when testing.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New datetime object rounded to ms from microseconds.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">datetime.datetime</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.to_milliseconds">
<code class="descclassname">pypond.util.</code><code class="descname">to_milliseconds</code><span class="sig-paren">(</span><em>dtime</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.to_milliseconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if a datetime object has granularity smaller
than millisecond (ie: microseconds) and massage back to ms if so.</p>
<p>Doing this round-trip seems kludgy and inefficient, but doing this:</p>
<p>return dtime.replace(millisecond=round(dt.millisecond, -3))</p>
<p>produced inconsistent results because of the rounding and I&#8217;m not
going to start treating numbers like strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtime</strong> (<em>datetime.datetime</em>) &#8211; A datetime object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">New datetime object rounded down to milliseconds from microseconds.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">datetime.datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pypond.util.unique_id">
<code class="descclassname">pypond.util.</code><code class="descname">unique_id</code><span class="sig-paren">(</span><em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#pypond.util.unique_id" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a uuid with a prefix - for debugging. This probably isn&#8217;t
truly random but it&#8217;s random enough. Calling uuid.uuid4() was imposing
non-trivial drag on performance. The calls to /dev/urandom can block
on certain unix-like systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prefix</strong> (<em>str, optional</em>) &#8211; Prefix for uuid.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Prefixed uuid.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pypond">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pypond" title="Permalink to this headline">¶</a></h2>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <a href="http://www.es.net/"><img src="_static/esnet/logo-esnet.png" alt="[ESnet]"></a>
      </div>
      <div class="col-md-11">
        <p class="pull-right">
        <a href="#">Back to top</a>
        
        <br/>
        
<div id="sourcelink">
  <a href="_sources/pypond.txt"
     rel="nofollow">Source</a>
</div>
        
        </p>
        <p>
            &copy; Copyright 2016, The Regents of the University of California.<br/>
          Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.1.<br/>
        </p>
      </div>
    </div>
  </div>
</footer>
  </body>
</html>